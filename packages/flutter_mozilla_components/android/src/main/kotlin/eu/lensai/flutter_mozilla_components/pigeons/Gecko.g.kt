// Autogenerated from Pigeon (v22.3.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")


import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private fun wrapResult(result: Any?): List<Any?> {
  return listOf(result)
}

private fun wrapError(exception: Throwable): List<Any?> {
  return if (exception is FlutterError) {
    listOf(
      exception.code,
      exception.message,
      exception.details
    )
  } else {
    listOf(
      exception.javaClass.simpleName,
      exception.toString(),
      "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
    )
  }
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Indicates what location the tabs should be restored at */
enum class RestoreLocation(val raw: Int) {
  /** Restore tabs at the beginning of the tab list */
  BEGINNING(0),
  /** Restore tabs at the end of the tab list */
  END(1),
  /** Restore tabs at a specific index in the tab list */
  AT_INDEX(2);

  companion object {
    fun ofRaw(raw: Int): RestoreLocation? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Translation options that map to the Gecko Translations Options.
 *
 * @property downloadModel If the necessary models should be downloaded on request. If false, then
 * the translation will not complete and throw an exception if the models are not already available.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TranslationOptions (
  val downloadModel: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TranslationOptions {
      val downloadModel = pigeonVar_list[0] as Boolean
      return TranslationOptions(downloadModel)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      downloadModel,
    )
  }
}

/**
 * Value type that represents the state of reader mode/view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ReaderState (
  /**
   * Whether or not the current page can be transformed to
   * be displayed in a reader view.
   */
  val readerable: Boolean,
  /** Whether or not reader view is active. */
  val active: Boolean,
  /**
   * Whether or not a readerable check is required for the
   * current page.
   */
  val checkRequired: Boolean,
  /**
   * Whether or not a new connection to the reader view
   * content script is required.
   */
  val connectRequired: Boolean,
  /** The base URL of the reader view extension page. */
  val baseUrl: String? = null,
  /** The URL of the page currently displayed in reader view. */
  val activeUrl: String? = null,
  /**
   * The vertical scroll position of the page currently
   * displayed in reader view.
   */
  val scrollY: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ReaderState {
      val readerable = pigeonVar_list[0] as Boolean
      val active = pigeonVar_list[1] as Boolean
      val checkRequired = pigeonVar_list[2] as Boolean
      val connectRequired = pigeonVar_list[3] as Boolean
      val baseUrl = pigeonVar_list[4] as String?
      val activeUrl = pigeonVar_list[5] as String?
      val scrollY = pigeonVar_list[6] as Long?
      return ReaderState(readerable, active, checkRequired, connectRequired, baseUrl, activeUrl, scrollY)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      readerable,
      active,
      checkRequired,
      connectRequired,
      baseUrl,
      activeUrl,
      scrollY,
    )
  }
}

/**
 * Details about the last playing media in this tab.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LastMediaAccessState (
  /**
   * [ContentState.url] when media started playing.
   * This is not the URL of the media but of the page when media started.
   * Defaults to "" (an empty String) if media hasn't started playing.
   * This value is only updated when media starts playing.
   * Can be used as a backup to [mediaSessionActive] for knowing the user is still on the same website
   * on which media was playing before media started playing in another tab.
   */
  val lastMediaUrl: String,
  /**
   * The last time media started playing in the current web document.
   * Defaults to [0] if media hasn't started playing.
   * This value is only updated when media starts playing.
   */
  val lastMediaAccess: Long,
  /**
   * Whether or not the last accessed media is still active.
   * Can be used as a backup to [lastMediaUrl] on websites which allow media to continue playing
   * even when the users accesses another page (with another URL) in that same HTML document.
   */
  val mediaSessionActive: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LastMediaAccessState {
      val lastMediaUrl = pigeonVar_list[0] as String
      val lastMediaAccess = pigeonVar_list[1] as Long
      val mediaSessionActive = pigeonVar_list[2] as Boolean
      return LastMediaAccessState(lastMediaUrl, lastMediaAccess, mediaSessionActive)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      lastMediaUrl,
      lastMediaAccess,
      mediaSessionActive,
    )
  }
}

/**
 * Represents a set of history metadata values that uniquely identify a record. Note that
 * when recording observations, the same set of values may or may not cause a new record to be
 * created, depending on the de-bouncing logic of the underlying storage i.e. recording history
 * metadata observations with the exact same values may be combined into a single record.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class HistoryMetadataKey (
  /** A url of the page. */
  val url: String,
  /**
   * An optional search term if this record was
   * created as part of a search by the user.
   */
  val searchTerm: String? = null,
  /**
   * An optional url of the parent/referrer if
   * this record was created in response to a user opening
   * a page in a new tab.
   */
  val referrerUrl: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryMetadataKey {
      val url = pigeonVar_list[0] as String
      val searchTerm = pigeonVar_list[1] as String?
      val referrerUrl = pigeonVar_list[2] as String?
      return HistoryMetadataKey(url, searchTerm, referrerUrl)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      searchTerm,
      referrerUrl,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PackageCategoryValue (
  val value: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PackageCategoryValue {
      val value = pigeonVar_list[0] as Long
      return PackageCategoryValue(value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
    )
  }
}

/**
 * Describes an external package.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ExternalPackage (
  /** An Android package id. */
  val packageId: String,
  /** A [PackageCategory] as defined by the application. */
  val category: PackageCategoryValue
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ExternalPackage {
      val packageId = pigeonVar_list[0] as String
      val category = pigeonVar_list[1] as PackageCategoryValue
      return ExternalPackage(packageId, category)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      packageId,
      category,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LoadUrlFlagsValue (
  val value: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LoadUrlFlagsValue {
      val value = pigeonVar_list[0] as Long
      return LoadUrlFlagsValue(value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
    )
  }
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SourceValue (
  val id: Long,
  val caller: ExternalPackage? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SourceValue {
      val id = pigeonVar_list[0] as Long
      val caller = pigeonVar_list[1] as ExternalPackage?
      return SourceValue(id, caller)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      caller,
    )
  }
}

/**
 * A tab that is no longer open and in the list of tabs, but that can be restored (recovered) at
 * any time if it's combined with an [EngineSessionState] to form a [RecoverableTab].
 *
 * The values of this data class are usually filled with the values of a [TabSessionState] when
 * getting closed.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TabState (
  /** Unique ID identifying this tab. */
  val id: String,
  /** The last URL of this tab. */
  val url: String,
  /**
   * The unique ID of the parent tab if this tab was opened from another tab (e.g. via
   * the context menu).
   */
  val parentId: String? = null,
  /** The last title of this tab (or an empty String). */
  val title: String,
  /**
   * The last used search terms, or an empty string if no
   * search was executed for this session.
   */
  val searchTerm: String,
  /** The context ID ("container") this tab used (or null). */
  val contextId: String? = null,
  /** The last [ReaderState] of the tab. */
  val readerState: ReaderState,
  /** The last time this tab was selected. */
  val lastAccess: Long,
  /** Timestamp of the tab's creation. */
  val createdAt: Long,
  /** Details about the last time was playing in this tab. */
  val lastMediaAccessState: LastMediaAccessState,
  /** If tab was private. */
  val private: Boolean,
  /** The last [HistoryMetadataKey] of the tab. */
  val historyMetadata: HistoryMetadataKey? = null,
  /** The last [Source] of the tab. */
  val source: SourceValue,
  /** The index the tab should be restored at. */
  val index: Long,
  /** Whether the tab has form data. */
  val hasFormData: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TabState {
      val id = pigeonVar_list[0] as String
      val url = pigeonVar_list[1] as String
      val parentId = pigeonVar_list[2] as String?
      val title = pigeonVar_list[3] as String
      val searchTerm = pigeonVar_list[4] as String
      val contextId = pigeonVar_list[5] as String?
      val readerState = pigeonVar_list[6] as ReaderState
      val lastAccess = pigeonVar_list[7] as Long
      val createdAt = pigeonVar_list[8] as Long
      val lastMediaAccessState = pigeonVar_list[9] as LastMediaAccessState
      val private = pigeonVar_list[10] as Boolean
      val historyMetadata = pigeonVar_list[11] as HistoryMetadataKey?
      val source = pigeonVar_list[12] as SourceValue
      val index = pigeonVar_list[13] as Long
      val hasFormData = pigeonVar_list[14] as Boolean
      return TabState(id, url, parentId, title, searchTerm, contextId, readerState, lastAccess, createdAt, lastMediaAccessState, private, historyMetadata, source, index, hasFormData)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      url,
      parentId,
      title,
      searchTerm,
      contextId,
      readerState,
      lastAccess,
      createdAt,
      lastMediaAccessState,
      private,
      historyMetadata,
      source,
      index,
      hasFormData,
    )
  }
}

/**
 * A recoverable version of [TabState].
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RecoverableTab (
  /** The [EngineSessionState] needed for restoring the previous state of this tab. */
  val engineSessionStateJson: String? = null,
  /** A [TabState] instance containing basic tab state. */
  val state: TabState
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RecoverableTab {
      val engineSessionStateJson = pigeonVar_list[0] as String?
      val state = pigeonVar_list[1] as TabState
      return RecoverableTab(engineSessionStateJson, state)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      engineSessionStateJson,
      state,
    )
  }
}

/**
 * A restored browser state, read from disk.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RecoverableBrowserState (
  /** The list of restored tabs. */
  val tabs: List<RecoverableTab?>,
  /** The ID of the selected tab in [tabs]. Or `null` if no selection was restored. */
  val selectedTabId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RecoverableBrowserState {
      val tabs = pigeonVar_list[0] as List<RecoverableTab?>
      val selectedTabId = pigeonVar_list[1] as String?
      return RecoverableBrowserState(tabs, selectedTabId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      tabs,
      selectedTabId,
    )
  }
}
private open class GeckoPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RestoreLocation.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TranslationOptions.fromList(it)
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ReaderState.fromList(it)
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LastMediaAccessState.fromList(it)
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryMetadataKey.fromList(it)
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PackageCategoryValue.fromList(it)
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ExternalPackage.fromList(it)
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LoadUrlFlagsValue.fromList(it)
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceValue.fromList(it)
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TabState.fromList(it)
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RecoverableTab.fromList(it)
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RecoverableBrowserState.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is RestoreLocation -> {
        stream.write(129)
        writeValue(stream, value.raw)
      }
      is TranslationOptions -> {
        stream.write(130)
        writeValue(stream, value.toList())
      }
      is ReaderState -> {
        stream.write(131)
        writeValue(stream, value.toList())
      }
      is LastMediaAccessState -> {
        stream.write(132)
        writeValue(stream, value.toList())
      }
      is HistoryMetadataKey -> {
        stream.write(133)
        writeValue(stream, value.toList())
      }
      is PackageCategoryValue -> {
        stream.write(134)
        writeValue(stream, value.toList())
      }
      is ExternalPackage -> {
        stream.write(135)
        writeValue(stream, value.toList())
      }
      is LoadUrlFlagsValue -> {
        stream.write(136)
        writeValue(stream, value.toList())
      }
      is SourceValue -> {
        stream.write(137)
        writeValue(stream, value.toList())
      }
      is TabState -> {
        stream.write(138)
        writeValue(stream, value.toList())
      }
      is RecoverableTab -> {
        stream.write(139)
        writeValue(stream, value.toList())
      }
      is RecoverableBrowserState -> {
        stream.write(140)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}

/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoBrowserApi {
  fun showNativeFragment()

  companion object {
    /** The codec used by GeckoBrowserApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoBrowserApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoBrowserApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.showNativeFragment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.showNativeFragment()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoSessionApi {
  fun loadUrl(tabId: String?, url: String, flags: LoadUrlFlagsValue, additionalHeaders: Map<String, String>?)
  fun loadData(tabId: String?, data: String, mimeType: String, encoding: String)
  fun reload(tabId: String?, flags: LoadUrlFlagsValue)
  fun stopLoading(tabId: String?)
  fun goBack(tabId: String?, userInteraction: Boolean)
  fun goForward(tabId: String?, userInteraction: Boolean)
  fun goToHistoryIndex(index: Long, tabId: String?)
  fun requestDesktopSite(tabId: String?, enable: Boolean)
  fun exitFullscreen(tabId: String?)
  fun saveToPdf(tabId: String?)
  fun printContent(tabId: String?)
  fun translate(tabId: String?, fromLanguage: String, toLanguage: String, options: TranslationOptions?)
  fun translateRestore(tabId: String?)
  fun crashRecovery(tabIds: List<String>?)
  fun purgeHistory()
  fun updateLastAccess(tabId: String?, lastAccess: Long?)

  companion object {
    /** The codec used by GeckoSessionApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoSessionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoSessionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val urlArg = args[1] as String
            val flagsArg = args[2] as LoadUrlFlagsValue
            val additionalHeadersArg = args[3] as Map<String, String>?
            val wrapped: List<Any?> = try {
              api.loadUrl(tabIdArg, urlArg, flagsArg, additionalHeadersArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val dataArg = args[1] as String
            val mimeTypeArg = args[2] as String
            val encodingArg = args[3] as String
            val wrapped: List<Any?> = try {
              api.loadData(tabIdArg, dataArg, mimeTypeArg, encodingArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.reload$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val flagsArg = args[1] as LoadUrlFlagsValue
            val wrapped: List<Any?> = try {
              api.reload(tabIdArg, flagsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.stopLoading$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.stopLoading(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goBack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val userInteractionArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.goBack(tabIdArg, userInteractionArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goForward$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val userInteractionArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.goForward(tabIdArg, userInteractionArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goToHistoryIndex$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val indexArg = args[0] as Long
            val tabIdArg = args[1] as String?
            val wrapped: List<Any?> = try {
              api.goToHistoryIndex(indexArg, tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.requestDesktopSite$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val enableArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.requestDesktopSite(tabIdArg, enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.exitFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.exitFullscreen(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.saveToPdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.saveToPdf(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.printContent$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.printContent(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val fromLanguageArg = args[1] as String
            val toLanguageArg = args[2] as String
            val optionsArg = args[3] as TranslationOptions?
            val wrapped: List<Any?> = try {
              api.translate(tabIdArg, fromLanguageArg, toLanguageArg, optionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translateRestore$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.translateRestore(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.crashRecovery$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdsArg = args[0] as List<String>?
            val wrapped: List<Any?> = try {
              api.crashRecovery(tabIdsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.purgeHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.purgeHistory()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.updateLastAccess$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val lastAccessArg = args[1] as Long?
            val wrapped: List<Any?> = try {
              api.updateLastAccess(tabIdArg, lastAccessArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoTabsApi {
  fun selectTab(tabId: String)
  fun removeTab(tabId: String)
  fun addTab(url: String, selectTab: Boolean, startLoading: Boolean, parentId: String?, flags: LoadUrlFlagsValue, contextId: String?, source: SourceValue, private: Boolean, historyMetadata: HistoryMetadataKey?, additionalHeaders: Map<String, String>?): String
  fun removeAllTabs(recoverable: Boolean)
  fun removeTabs(ids: List<String>)
  fun removeNormalTabs()
  fun removePrivateTabs()
  fun undo()
  fun restoreTabsByList(tabs: List<RecoverableTab>, selectTabId: String?, restoreLocation: RestoreLocation)
  fun restoreTabsByBrowserState(state: RecoverableBrowserState, restoreLocation: RestoreLocation)
  /**
   * Selects an already existing tab with the matching [HistoryMetadataKey] or otherwise
   * creates a new tab with the given [url].
   */
  fun selectOrAddTabByHistory(url: String, historyMetadata: HistoryMetadataKey): String
  /** Selects an already existing tab displaying [url] or otherwise creates a new tab. */
  fun selectOrAddTabByUrl(url: String, private: Boolean, source: SourceValue, flags: LoadUrlFlagsValue, ignoreFragment: Boolean): String
  fun duplicateTab(selectTabId: String?, selectNewTab: Boolean): String
  fun moveTabs(tabIds: List<String>, targetTabId: String, placeAfter: Boolean)
  fun migratePrivateTabUseCase(tabId: String, alternativeUrl: String?): String

  companion object {
    /** The codec used by GeckoTabsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoTabsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoTabsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.selectTab(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.removeTab(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.addTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val selectTabArg = args[1] as Boolean
            val startLoadingArg = args[2] as Boolean
            val parentIdArg = args[3] as String?
            val flagsArg = args[4] as LoadUrlFlagsValue
            val contextIdArg = args[5] as String?
            val sourceArg = args[6] as SourceValue
            val privateArg = args[7] as Boolean
            val historyMetadataArg = args[8] as HistoryMetadataKey?
            val additionalHeadersArg = args[9] as Map<String, String>?
            val wrapped: List<Any?> = try {
              listOf(api.addTab(urlArg, selectTabArg, startLoadingArg, parentIdArg, flagsArg, contextIdArg, sourceArg, privateArg, historyMetadataArg, additionalHeadersArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeAllTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val recoverableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.removeAllTabs(recoverableArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idsArg = args[0] as List<String>
            val wrapped: List<Any?> = try {
              api.removeTabs(idsArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeNormalTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.removeNormalTabs()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removePrivateTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.removePrivateTabs()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.undo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.undo()
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByList$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabsArg = args[0] as List<RecoverableTab>
            val selectTabIdArg = args[1] as String?
            val restoreLocationArg = args[2] as RestoreLocation
            val wrapped: List<Any?> = try {
              api.restoreTabsByList(tabsArg, selectTabIdArg, restoreLocationArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByBrowserState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val stateArg = args[0] as RecoverableBrowserState
            val restoreLocationArg = args[1] as RestoreLocation
            val wrapped: List<Any?> = try {
              api.restoreTabsByBrowserState(stateArg, restoreLocationArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val historyMetadataArg = args[1] as HistoryMetadataKey
            val wrapped: List<Any?> = try {
              listOf(api.selectOrAddTabByHistory(urlArg, historyMetadataArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val privateArg = args[1] as Boolean
            val sourceArg = args[2] as SourceValue
            val flagsArg = args[3] as LoadUrlFlagsValue
            val ignoreFragmentArg = args[4] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.selectOrAddTabByUrl(urlArg, privateArg, sourceArg, flagsArg, ignoreFragmentArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.duplicateTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val selectTabIdArg = args[0] as String?
            val selectNewTabArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.duplicateTab(selectTabIdArg, selectNewTabArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.moveTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdsArg = args[0] as List<String>
            val targetTabIdArg = args[1] as String
            val placeAfterArg = args[2] as Boolean
            val wrapped: List<Any?> = try {
              api.moveTabs(tabIdsArg, targetTabIdArg, placeAfterArg)
              listOf(null)
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.migratePrivateTabUseCase$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val alternativeUrlArg = args[1] as String?
            val wrapped: List<Any?> = try {
              listOf(api.migratePrivateTabUseCase(tabIdArg, alternativeUrlArg))
            } catch (exception: Throwable) {
              wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
