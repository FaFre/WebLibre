// Autogenerated from Pigeon (v26.1.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon
@file:Suppress("UNCHECKED_CAST", "ArrayInDataClass")

package eu.weblibre.flutter_mozilla_components.pigeons

import android.util.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.EventChannel
import io.flutter.plugin.common.MessageCodec
import io.flutter.plugin.common.StandardMethodCodec
import io.flutter.plugin.common.StandardMessageCodec
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
private object GeckoPigeonUtils {

  fun createConnectionError(channelName: String): FlutterError {
    return FlutterError("channel-error",  "Unable to establish connection on channel: '$channelName'.", "")  }

  fun wrapResult(result: Any?): List<Any?> {
    return listOf(result)
  }

  fun wrapError(exception: Throwable): List<Any?> {
    return if (exception is FlutterError) {
      listOf(
        exception.code,
        exception.message,
        exception.details
      )
    } else {
      listOf(
        exception.javaClass.simpleName,
        exception.toString(),
        "Cause: " + exception.cause + ", Stacktrace: " + Log.getStackTraceString(exception)
      )
    }
  }
  fun deepEquals(a: Any?, b: Any?): Boolean {
    if (a is ByteArray && b is ByteArray) {
        return a.contentEquals(b)
    }
    if (a is IntArray && b is IntArray) {
        return a.contentEquals(b)
    }
    if (a is LongArray && b is LongArray) {
        return a.contentEquals(b)
    }
    if (a is DoubleArray && b is DoubleArray) {
        return a.contentEquals(b)
    }
    if (a is Array<*> && b is Array<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is List<*> && b is List<*>) {
      return a.size == b.size &&
          a.indices.all{ deepEquals(a[it], b[it]) }
    }
    if (a is Map<*, *> && b is Map<*, *>) {
      return a.size == b.size && a.all {
          (b as Map<Any?, Any?>).contains(it.key) &&
          deepEquals(it.value, b[it.key])
      }
    }
    return a == b
  }
      
}

/**
 * Error class for passing custom error details to Flutter via a thrown PlatformException.
 * @property code The error code.
 * @property message The error message.
 * @property details The error details. Must be a datatype supported by the api codec.
 */
class FlutterError (
  val code: String,
  override val message: String? = null,
  val details: Any? = null
) : Throwable()

/** Indicates what location the tabs should be restored at */
enum class RestoreLocation(val raw: Int) {
  /** Restore tabs at the beginning of the tab list */
  BEGINNING(0),
  /** Restore tabs at the end of the tab list */
  END(1),
  /** Restore tabs at a specific index in the tab list */
  AT_INDEX(2);

  companion object {
    fun ofRaw(raw: Int): RestoreLocation? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** An icon resource type. */
enum class IconType(val raw: Int) {
  FAVICON(0),
  APPLE_TOUCH_ICON(1),
  FLUID_ICON(2),
  IMAGE_SRC(3),
  OPEN_GRAPH(4),
  TWITTER(5),
  MICROSOFT_TILE(6),
  TIPPY_TOP(7),
  MANIFEST_ICON(8);

  companion object {
    fun ofRaw(raw: Int): IconType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Supported sizes.
 *
 * We are trying to limit the supported sizes in order to optimize our caching strategy.
 */
enum class IconSize(val raw: Int) {
  DEFAULT_SIZE(0),
  LAUNCHER(1),
  LAUNCHER_ADAPTIVE(2);

  companion object {
    fun ofRaw(raw: Int): IconSize? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** The source of an [Icon]. */
enum class IconSource(val raw: Int) {
  /** This icon was generated. */
  GENERATOR(0),
  /** This icon was downloaded. */
  DOWNLOAD(1),
  /** This icon was inlined in the document. */
  INLINE(2),
  /** This icon was loaded from an in-memory cache. */
  MEMORY(3),
  /** This icon was loaded from a disk cache. */
  DISK(4);

  companion object {
    fun ofRaw(raw: Int): IconSource? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CookieSameSiteStatus(val raw: Int) {
  NO_RESTRICTION(0),
  LAX(1),
  STRICT(2),
  UNSPECIFIED(3);

  companion object {
    fun ofRaw(raw: Int): CookieSameSiteStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class VisitType(val raw: Int) {
  /** The user followed a link and got a new toplevel window. */
  LINK(0),
  /**
   * The user typed the page's URL in the URL bar or selected it from
   * URL bar autocomplete results, clicked on it from a history query
   * (from the History sidebar, History menu, or history query in the
   * personal toolbar or Places organizer.
   */
  TYPED(1),
  /** The user followed a bookmark to get to the page. */
  BOOKMARK(2),
  /**
   * Some inner content is loaded. This is true of all images on a
   * page, and the contents of the iframe. It is also true of any
   * content in a frame if the user did not explicitly follow a link
   * to get there.
   */
  EMBED(3),
  /** Set when the transition was a permanent redirect. */
  REDIRECT_PERMANENT(4),
  /** Set when the transition was a temporary redirect. */
  REDIRECT_TEMPORARY(5),
  /** Set when the transition is a download. */
  DOWNLOAD(6),
  /** The user followed a link and got a visit in a frame. */
  FRAMED_LINK(7),
  /** The user reloaded a page. */
  RELOAD(8);

  companion object {
    fun ofRaw(raw: Int): VisitType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class SelectionPattern(val raw: Int) {
  PHONE(0),
  EMAIL(1);

  companion object {
    fun ofRaw(raw: Int): SelectionPattern? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class WebExtensionActionType(val raw: Int) {
  BROWSER(0),
  PAGE(1);

  companion object {
    fun ofRaw(raw: Int): WebExtensionActionType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class GeckoSuggestionType(val raw: Int) {
  SESSION(0),
  CLIPBOARD(1),
  HISTORY(2);

  companion object {
    fun ofRaw(raw: Int): GeckoSuggestionType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class TrackingProtectionPolicy(val raw: Int) {
  NONE(0),
  RECOMMENDED(1),
  STRICT(2),
  CUSTOM(3);

  companion object {
    fun ofRaw(raw: Int): TrackingProtectionPolicy? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class HttpsOnlyMode(val raw: Int) {
  DISABLED(0),
  PRIVATE_ONLY(1),
  ENABLED(2);

  companion object {
    fun ofRaw(raw: Int): HttpsOnlyMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class QueryParameterStripping(val raw: Int) {
  DISABLED(0),
  PRIVATE_ONLY(1),
  ENABLED(2);

  companion object {
    fun ofRaw(raw: Int): QueryParameterStripping? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class BounceTrackingProtectionMode(val raw: Int) {
  /** Fully disabled. */
  DISABLED(0),
  /** Fully enabled. */
  ENABLED(1),
  /**
   * Disabled, but collects user interaction data. Use this mode as the
   * "disabled" state when the feature can be toggled on and off, e.g. via
   * preferences.
   */
  ENABLED_STANDBY(2),
  /**
   * Feature enabled, but tracker purging is only simulated. Used for
   * testing and telemetry collection.
   */
  ENABLED_DRY_RUN(3);

  companion object {
    fun ofRaw(raw: Int): BounceTrackingProtectionMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class ColorScheme(val raw: Int) {
  SYSTEM(0),
  LIGHT(1),
  DARK(2);

  companion object {
    fun ofRaw(raw: Int): ColorScheme? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class CookieBannerHandlingMode(val raw: Int) {
  DISABLED(0),
  REJECT_ALL(1),
  REJECT_OR_ACCEPT_ALL(2);

  companion object {
    fun ofRaw(raw: Int): CookieBannerHandlingMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** App links behavior mode - controls how external app links are handled */
enum class AppLinksMode(val raw: Int) {
  /** Always open links in their native apps without prompting */
  ALWAYS(0),
  /** Prompt user before opening in app (with "Always open" checkbox) */
  ASK(1),
  /** Never open links in external apps, always use browser */
  NEVER(2);

  companion object {
    fun ofRaw(raw: Int): AppLinksMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class WebContentIsolationStrategy(val raw: Int) {
  ISOLATE_NOTHING(0),
  ISOLATE_EVERYTHING(1),
  ISOLATE_HIGH_VALUE(2);

  companion object {
    fun ofRaw(raw: Int): WebContentIsolationStrategy? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Cookie blocking policy for Custom tracking protection mode.
 * Note: These only apply when blockCookies is true.
 */
enum class CustomCookiePolicy(val raw: Int) {
  /**
   * Total Cookie Protection - Dynamic First-Party Isolation (dFPI)
   * Most private option, isolates cookies per site
   */
  TOTAL_PROTECTION(0),
  /**
   * Block cross-site and social media tracker cookies
   * Allows most cookies but blocks tracking cookies
   */
  CROSS_SITE_TRACKERS(1),
  /**
   * Block cookies from sites you haven't visited
   * Balances privacy with functionality
   */
  UNVISITED(2),
  /**
   * Block all third-party cookies
   * Only allows first-party cookies
   */
  THIRD_PARTY(3),
  /** Block all cookies (may break many sites) */
  ALL_COOKIES(4);

  companion object {
    fun ofRaw(raw: Int): CustomCookiePolicy? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Scope for applying tracking protection features */
enum class TrackingScope(val raw: Int) {
  /** Apply to all browsing (normal + private) */
  ALL(0),
  /** Apply only to private browsing tabs */
  PRIVATE_ONLY(1);

  companion object {
    fun ofRaw(raw: Int): TrackingScope? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class DohSettingsMode(val raw: Int) {
  GECKO_DEFAULT(0),
  INCREASED(1),
  MAX(2),
  OFF(3);

  companion object {
    fun ofRaw(raw: Int): DohSettingsMode? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Status that represents every state that a download can be in. */
enum class DownloadStatus(val raw: Int) {
  /** Indicates that the download is in the first state after creation but not yet [DOWNLOADING]. */
  INITIATED(0),
  /** Indicates that an [INITIATED] download is now actively being downloaded. */
  DOWNLOADING(1),
  /** Indicates that the download that has been [DOWNLOADING] has been paused. */
  PAUSED(2),
  /** Indicates that the download that has been [DOWNLOADING] has been cancelled. */
  CANCELLED(3),
  /**
   * Indicates that the download that has been [DOWNLOADING] has moved to failed because
   * something unexpected has happened.
   */
  FAILED(4),
  /** Indicates that the [DOWNLOADING] download has been completed. */
  COMPLETED(5);

  companion object {
    fun ofRaw(raw: Int): DownloadStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class LogLevel(val raw: Int) {
  DEBUG(0),
  INFO(1),
  WARN(2),
  ERROR(3);

  companion object {
    fun ofRaw(raw: Int): LogLevel? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Type of ML model operation */
enum class MlProgressType(val raw: Int) {
  DOWNLOADING(0),
  LOADING_FROM_CACHE(1),
  RUNNING_INFERENCE(2);

  companion object {
    fun ofRaw(raw: Int): MlProgressType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Status of the ML operation */
enum class MlProgressStatus(val raw: Int) {
  INITIATE(0),
  SIZE_ESTIMATE(1),
  IN_PROGRESS(2),
  DONE(3);

  companion object {
    fun ofRaw(raw: Int): MlProgressStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Types of browsing data that can be cleared */
enum class ClearDataType(val raw: Int) {
  /** Authentication sessions */
  AUTH_SESSIONS(0),
  /** All site data (cookies, storage, etc.) */
  ALL_SITE_DATA(1),
  /** Cookies only */
  COOKIES(2),
  /** Cache only */
  ALL_CACHES(3);

  companion object {
    fun ofRaw(raw: Int): ClearDataType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class GeckoFetchMethod(val raw: Int) {
  GET(0),
  HEAD(1),
  POST(2),
  PUT(3),
  DELETE(4),
  CONNECT(5),
  OPTIONS(6),
  TRACE(7);

  companion object {
    fun ofRaw(raw: Int): GeckoFetchMethod? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class GeckoFetchRedircet(val raw: Int) {
  FOLLOW(0),
  MANUAL(1);

  companion object {
    fun ofRaw(raw: Int): GeckoFetchRedircet? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class GeckoFetchCookiePolicy(val raw: Int) {
  INCLUDE(0),
  OMIT(1);

  companion object {
    fun ofRaw(raw: Int): GeckoFetchCookiePolicy? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

enum class BookmarkNodeType(val raw: Int) {
  ITEM(0),
  FOLDER(1),
  SEPARATOR(2);

  companion object {
    fun ofRaw(raw: Int): BookmarkNodeType? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Permission status for a site permission */
enum class SitePermissionStatus(val raw: Int) {
  /** Permission has been granted */
  ALLOWED(0),
  /** Permission has been denied */
  BLOCKED(1),
  /** No decision has been made yet (ask to allow) */
  NO_DECISION(2);

  companion object {
    fun ofRaw(raw: Int): SitePermissionStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/** Autoplay permission values (matches Fenix's 4 states) */
enum class AutoplayStatus(val raw: Int) {
  /** Allow all autoplay (audible and inaudible) */
  ALLOWED(0),
  /** Block all autoplay */
  BLOCKED(1),
  /** Block audible autoplay only (allow inaudible) */
  BLOCK_AUDIBLE(2),
  /** Allow autoplay on WiFi only */
  ALLOW_ON_WIFI(3);

  companion object {
    fun ofRaw(raw: Int): AutoplayStatus? {
      return values().firstOrNull { it.raw == raw }
    }
  }
}

/**
 * Translation options that map to the Gecko Translations Options.
 *
 * @property downloadModel If the necessary models should be downloaded on request. If false, then
 * the translation will not complete and throw an exception if the models are not already available.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TranslationOptions (
  val downloadModel: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TranslationOptions {
      val downloadModel = pigeonVar_list[0] as Boolean
      return TranslationOptions(downloadModel)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      downloadModel,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TranslationOptions) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Value type that represents the state of reader mode/view.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ReaderState (
  /**
   * Whether or not the current page can be transformed to
   * be displayed in a reader view.
   */
  val readerable: Boolean,
  /** Whether or not reader view is active. */
  val active: Boolean,
  /**
   * Whether or not a readerable check is required for the
   * current page.
   */
  val checkRequired: Boolean,
  /**
   * Whether or not a new connection to the reader view
   * content script is required.
   */
  val connectRequired: Boolean,
  /** The base URL of the reader view extension page. */
  val baseUrl: String? = null,
  /** The URL of the page currently displayed in reader view. */
  val activeUrl: String? = null,
  /**
   * The vertical scroll position of the page currently
   * displayed in reader view.
   */
  val scrollY: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ReaderState {
      val readerable = pigeonVar_list[0] as Boolean
      val active = pigeonVar_list[1] as Boolean
      val checkRequired = pigeonVar_list[2] as Boolean
      val connectRequired = pigeonVar_list[3] as Boolean
      val baseUrl = pigeonVar_list[4] as String?
      val activeUrl = pigeonVar_list[5] as String?
      val scrollY = pigeonVar_list[6] as Long?
      return ReaderState(readerable, active, checkRequired, connectRequired, baseUrl, activeUrl, scrollY)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      readerable,
      active,
      checkRequired,
      connectRequired,
      baseUrl,
      activeUrl,
      scrollY,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ReaderState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Parameters for adding a new tab.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AddTabParams (
  val url: String,
  val startLoading: Boolean,
  val parentId: String? = null,
  val flags: LoadUrlFlagsValue,
  val contextId: String? = null,
  val source: SourceValue,
  val private: Boolean,
  val historyMetadata: HistoryMetadataKey? = null,
  val additionalHeaders: Map<String, String>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AddTabParams {
      val url = pigeonVar_list[0] as String
      val startLoading = pigeonVar_list[1] as Boolean
      val parentId = pigeonVar_list[2] as String?
      val flags = pigeonVar_list[3] as LoadUrlFlagsValue
      val contextId = pigeonVar_list[4] as String?
      val source = pigeonVar_list[5] as SourceValue
      val private = pigeonVar_list[6] as Boolean
      val historyMetadata = pigeonVar_list[7] as HistoryMetadataKey?
      val additionalHeaders = pigeonVar_list[8] as Map<String, String>?
      return AddTabParams(url, startLoading, parentId, flags, contextId, source, private, historyMetadata, additionalHeaders)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      startLoading,
      parentId,
      flags,
      contextId,
      source,
      private,
      historyMetadata,
      additionalHeaders,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is AddTabParams) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Details about the last playing media in this tab.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class LastMediaAccessState (
  /**
   * [TabContentState.url] when media started playing.
   * This is not the URL of the media but of the page when media started.
   * Defaults to "" (an empty String) if media hasn't started playing.
   * This value is only updated when media starts playing.
   * Can be used as a backup to [mediaSessionActive] for knowing the user is still on the same website
   * on which media was playing before media started playing in another tab.
   */
  val lastMediaUrl: String,
  /**
   * The last time media started playing in the current web document.
   * Defaults to [0] if media hasn't started playing.
   * This value is only updated when media starts playing.
   */
  val lastMediaAccess: Long,
  /**
   * Whether or not the last accessed media is still active.
   * Can be used as a backup to [lastMediaUrl] on websites which allow media to continue playing
   * even when the users accesses another page (with another URL) in that same HTML document.
   */
  val mediaSessionActive: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LastMediaAccessState {
      val lastMediaUrl = pigeonVar_list[0] as String
      val lastMediaAccess = pigeonVar_list[1] as Long
      val mediaSessionActive = pigeonVar_list[2] as Boolean
      return LastMediaAccessState(lastMediaUrl, lastMediaAccess, mediaSessionActive)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      lastMediaUrl,
      lastMediaAccess,
      mediaSessionActive,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is LastMediaAccessState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Represents a set of history metadata values that uniquely identify a record. Note that
 * when recording observations, the same set of values may or may not cause a new record to be
 * created, depending on the de-bouncing logic of the underlying storage i.e. recording history
 * metadata observations with the exact same values may be combined into a single record.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class HistoryMetadataKey (
  /** A url of the page. */
  val url: String,
  /**
   * An optional search term if this record was
   * created as part of a search by the user.
   */
  val searchTerm: String? = null,
  /**
   * An optional url of the parent/referrer if
   * this record was created in response to a user opening
   * a page in a new tab.
   */
  val referrerUrl: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryMetadataKey {
      val url = pigeonVar_list[0] as String
      val searchTerm = pigeonVar_list[1] as String?
      val referrerUrl = pigeonVar_list[2] as String?
      return HistoryMetadataKey(url, searchTerm, referrerUrl)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      searchTerm,
      referrerUrl,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is HistoryMetadataKey) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class PackageCategoryValue (
  val value: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PackageCategoryValue {
      val value = pigeonVar_list[0] as Long
      return PackageCategoryValue(value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PackageCategoryValue) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Describes an external package.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ExternalPackage (
  /** An Android package id. */
  val packageId: String,
  /** A [PackageCategory] as defined by the application. */
  val category: PackageCategoryValue
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ExternalPackage {
      val packageId = pigeonVar_list[0] as String
      val category = pigeonVar_list[1] as PackageCategoryValue
      return ExternalPackage(packageId, category)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      packageId,
      category,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ExternalPackage) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class LoadUrlFlagsValue (
  val value: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): LoadUrlFlagsValue {
      val value = pigeonVar_list[0] as Long
      return LoadUrlFlagsValue(value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      value,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is LoadUrlFlagsValue) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SourceValue (
  val id: Long,
  val caller: ExternalPackage? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SourceValue {
      val id = pigeonVar_list[0] as Long
      val caller = pigeonVar_list[1] as ExternalPackage?
      return SourceValue(id, caller)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      caller,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is SourceValue) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * A tab that is no longer open and in the list of tabs, but that can be restored (recovered) at
 * any time if it's combined with an [EngineSessionState] to form a [RecoverableTab].
 *
 * The values of this data class are usually filled with the values of a [TabSessionState] when
 * getting closed.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TabState (
  /** Unique ID identifying this tab. */
  val id: String,
  /** The last URL of this tab. */
  val url: String,
  /**
   * The unique ID of the parent tab if this tab was opened from another tab (e.g. via
   * the context menu).
   */
  val parentId: String? = null,
  /** The last title of this tab (or an empty String). */
  val title: String,
  /**
   * The last used search terms, or an empty string if no
   * search was executed for this session.
   */
  val searchTerm: String,
  /** The context ID ("container") this tab used (or null). */
  val contextId: String? = null,
  /** The last [ReaderState] of the tab. */
  val readerState: ReaderState,
  /** The last time this tab was selected. */
  val lastAccess: Long,
  /** Timestamp of the tab's creation. */
  val createdAt: Long,
  /** Details about the last time was playing in this tab. */
  val lastMediaAccessState: LastMediaAccessState,
  /** If tab was private. */
  val private: Boolean,
  /** The last [HistoryMetadataKey] of the tab. */
  val historyMetadata: HistoryMetadataKey? = null,
  /** The last [IconSource] of the tab. */
  val source: SourceValue,
  /** The index the tab should be restored at. */
  val index: Long,
  /** Whether the tab has form data. */
  val hasFormData: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TabState {
      val id = pigeonVar_list[0] as String
      val url = pigeonVar_list[1] as String
      val parentId = pigeonVar_list[2] as String?
      val title = pigeonVar_list[3] as String
      val searchTerm = pigeonVar_list[4] as String
      val contextId = pigeonVar_list[5] as String?
      val readerState = pigeonVar_list[6] as ReaderState
      val lastAccess = pigeonVar_list[7] as Long
      val createdAt = pigeonVar_list[8] as Long
      val lastMediaAccessState = pigeonVar_list[9] as LastMediaAccessState
      val private = pigeonVar_list[10] as Boolean
      val historyMetadata = pigeonVar_list[11] as HistoryMetadataKey?
      val source = pigeonVar_list[12] as SourceValue
      val index = pigeonVar_list[13] as Long
      val hasFormData = pigeonVar_list[14] as Boolean
      return TabState(id, url, parentId, title, searchTerm, contextId, readerState, lastAccess, createdAt, lastMediaAccessState, private, historyMetadata, source, index, hasFormData)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      url,
      parentId,
      title,
      searchTerm,
      contextId,
      readerState,
      lastAccess,
      createdAt,
      lastMediaAccessState,
      private,
      historyMetadata,
      source,
      index,
      hasFormData,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TabState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * A recoverable version of [TabState].
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RecoverableTab (
  /** The [EngineSessionState] needed for restoring the previous state of this tab. */
  val engineSessionStateJson: String? = null,
  /** A [TabState] instance containing basic tab state. */
  val state: TabState
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RecoverableTab {
      val engineSessionStateJson = pigeonVar_list[0] as String?
      val state = pigeonVar_list[1] as TabState
      return RecoverableTab(engineSessionStateJson, state)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      engineSessionStateJson,
      state,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RecoverableTab) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * A restored browser state, read from disk.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class RecoverableBrowserState (
  /** The list of restored tabs. */
  val tabs: List<RecoverableTab?>,
  /** The ID of the selected tab in [tabs]. Or `null` if no selection was restored. */
  val selectedTabId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): RecoverableBrowserState {
      val tabs = pigeonVar_list[0] as List<RecoverableTab?>
      val selectedTabId = pigeonVar_list[1] as String?
      return RecoverableBrowserState(tabs, selectedTabId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      tabs,
      selectedTabId,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is RecoverableBrowserState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * A request to load an [Icon].
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class IconRequest (
  val url: String,
  val size: IconSize,
  val resources: List<Resource?>,
  val color: Long? = null,
  val isPrivate: Boolean,
  val waitOnNetworkLoad: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): IconRequest {
      val url = pigeonVar_list[0] as String
      val size = pigeonVar_list[1] as IconSize
      val resources = pigeonVar_list[2] as List<Resource?>
      val color = pigeonVar_list[3] as Long?
      val isPrivate = pigeonVar_list[4] as Boolean
      val waitOnNetworkLoad = pigeonVar_list[5] as Boolean
      return IconRequest(url, size, resources, color, isPrivate, waitOnNetworkLoad)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      size,
      resources,
      color,
      isPrivate,
      waitOnNetworkLoad,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is IconRequest) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ResourceSize (
  val height: Long,
  val width: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ResourceSize {
      val height = pigeonVar_list[0] as Long
      val width = pigeonVar_list[1] as Long
      return ResourceSize(height, width)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      height,
      width,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ResourceSize) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * An icon resource that can be loaded.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class Resource (
  val url: String,
  val type: IconType,
  val sizes: List<ResourceSize?>,
  val mimeType: String? = null,
  val maskable: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Resource {
      val url = pigeonVar_list[0] as String
      val type = pigeonVar_list[1] as IconType
      val sizes = pigeonVar_list[2] as List<ResourceSize?>
      val mimeType = pigeonVar_list[3] as String?
      val maskable = pigeonVar_list[4] as Boolean
      return Resource(url, type, sizes, mimeType, maskable)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      type,
      sizes,
      mimeType,
      maskable,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is Resource) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * An [Icon] returned by [BrowserIcons] after processing an [IconRequest]
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class IconResult (
  /** The loaded icon as an [Uint8List]. */
  val image: ByteArray,
  /** The dominant color of the icon. Will be null if no color could be extracted. */
  val color: Long? = null,
  /** The source of the icon. */
  val source: IconSource,
  /** True if the icon represents as full-bleed icon that can be cropped to other shapes. */
  val maskable: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): IconResult {
      val image = pigeonVar_list[0] as ByteArray
      val color = pigeonVar_list[1] as Long?
      val source = pigeonVar_list[2] as IconSource
      val maskable = pigeonVar_list[3] as Boolean
      return IconResult(image, color, source, maskable)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      image,
      color,
      source,
      maskable,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is IconResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CookiePartitionKey (
  val topLevelSite: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CookiePartitionKey {
      val topLevelSite = pigeonVar_list[0] as String
      return CookiePartitionKey(topLevelSite)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      topLevelSite,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CookiePartitionKey) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class Cookie (
  val domain: String,
  val expirationDate: Long? = null,
  val firstPartyDomain: String,
  val hostOnly: Boolean,
  val httpOnly: Boolean,
  val name: String,
  val partitionKey: CookiePartitionKey? = null,
  val path: String,
  val secure: Boolean,
  val session: Boolean,
  val sameSite: CookieSameSiteStatus,
  val storeId: String,
  val value: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): Cookie {
      val domain = pigeonVar_list[0] as String
      val expirationDate = pigeonVar_list[1] as Long?
      val firstPartyDomain = pigeonVar_list[2] as String
      val hostOnly = pigeonVar_list[3] as Boolean
      val httpOnly = pigeonVar_list[4] as Boolean
      val name = pigeonVar_list[5] as String
      val partitionKey = pigeonVar_list[6] as CookiePartitionKey?
      val path = pigeonVar_list[7] as String
      val secure = pigeonVar_list[8] as Boolean
      val session = pigeonVar_list[9] as Boolean
      val sameSite = pigeonVar_list[10] as CookieSameSiteStatus
      val storeId = pigeonVar_list[11] as String
      val value = pigeonVar_list[12] as String
      return Cookie(domain, expirationDate, firstPartyDomain, hostOnly, httpOnly, name, partitionKey, path, secure, session, sameSite, storeId, value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      domain,
      expirationDate,
      firstPartyDomain,
      hostOnly,
      httpOnly,
      name,
      partitionKey,
      path,
      secure,
      session,
      sameSite,
      storeId,
      value,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is Cookie) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class VisitInfo (
  val url: String,
  val title: String? = null,
  val visitTime: Long,
  val visitType: VisitType,
  val previewImageUrl: String? = null,
  val isRemote: Boolean,
  val contentId: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VisitInfo {
      val url = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String?
      val visitTime = pigeonVar_list[2] as Long
      val visitType = pigeonVar_list[3] as VisitType
      val previewImageUrl = pigeonVar_list[4] as String?
      val isRemote = pigeonVar_list[5] as Boolean
      val contentId = pigeonVar_list[6] as String?
      return VisitInfo(url, title, visitTime, visitType, previewImageUrl, isRemote, contentId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      title,
      visitTime,
      visitType,
      previewImageUrl,
      isRemote,
      contentId,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is VisitInfo) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class HistoryItem (
  val url: String,
  val title: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryItem {
      val url = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String
      return HistoryItem(url, title)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      title,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is HistoryItem) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class HistoryState (
  val items: List<HistoryItem?>,
  val currentIndex: Long,
  val canGoBack: Boolean,
  val canGoForward: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): HistoryState {
      val items = pigeonVar_list[0] as List<HistoryItem?>
      val currentIndex = pigeonVar_list[1] as Long
      val canGoBack = pigeonVar_list[2] as Boolean
      val canGoForward = pigeonVar_list[3] as Boolean
      return HistoryState(items, currentIndex, canGoBack, canGoForward)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      items,
      currentIndex,
      canGoBack,
      canGoForward,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is HistoryState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ReaderableState (
  /**
   * Whether or not the current page can be transformed to
   * be displayed in a reader view.
   */
  val readerable: Boolean,
  /** Whether or not reader view is active. */
  val active: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ReaderableState {
      val readerable = pigeonVar_list[0] as Boolean
      val active = pigeonVar_list[1] as Boolean
      return ReaderableState(readerable, active)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      readerable,
      active,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ReaderableState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class SecurityInfoState (
  val secure: Boolean,
  val host: String,
  val issuer: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SecurityInfoState {
      val secure = pigeonVar_list[0] as Boolean
      val host = pigeonVar_list[1] as String
      val issuer = pigeonVar_list[2] as String
      return SecurityInfoState(secure, host, issuer)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      secure,
      host,
      issuer,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is SecurityInfoState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TabContentState (
  val id: String,
  val parentId: String? = null,
  val contextId: String? = null,
  val url: String,
  val title: String,
  val progress: Long,
  val isPrivate: Boolean,
  val isFullScreen: Boolean,
  val isLoading: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TabContentState {
      val id = pigeonVar_list[0] as String
      val parentId = pigeonVar_list[1] as String?
      val contextId = pigeonVar_list[2] as String?
      val url = pigeonVar_list[3] as String
      val title = pigeonVar_list[4] as String
      val progress = pigeonVar_list[5] as Long
      val isPrivate = pigeonVar_list[6] as Boolean
      val isFullScreen = pigeonVar_list[7] as Boolean
      val isLoading = pigeonVar_list[8] as Boolean
      return TabContentState(id, parentId, contextId, url, title, progress, isPrivate, isFullScreen, isLoading)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      parentId,
      contextId,
      url,
      title,
      progress,
      isPrivate,
      isFullScreen,
      isLoading,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TabContentState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class FindResultState (
  val activeMatchOrdinal: Long,
  val numberOfMatches: Long,
  val isDoneCounting: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): FindResultState {
      val activeMatchOrdinal = pigeonVar_list[0] as Long
      val numberOfMatches = pigeonVar_list[1] as Long
      val isDoneCounting = pigeonVar_list[2] as Boolean
      return FindResultState(activeMatchOrdinal, numberOfMatches, isDoneCounting)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      activeMatchOrdinal,
      numberOfMatches,
      isDoneCounting,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is FindResultState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class CustomSelectionAction (
  val id: String,
  val title: String,
  val pattern: SelectionPattern? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): CustomSelectionAction {
      val id = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String
      val pattern = pigeonVar_list[2] as SelectionPattern?
      return CustomSelectionAction(id, title, pattern)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      title,
      pattern,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is CustomSelectionAction) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class WebExtensionData (
  val extensionId: String,
  val title: String? = null,
  val enabled: Boolean? = null,
  val badgeText: String? = null,
  val badgeTextColor: Long? = null,
  val badgeBackgroundColor: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): WebExtensionData {
      val extensionId = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String?
      val enabled = pigeonVar_list[2] as Boolean?
      val badgeText = pigeonVar_list[3] as String?
      val badgeTextColor = pigeonVar_list[4] as Long?
      val badgeBackgroundColor = pigeonVar_list[5] as Long?
      return WebExtensionData(extensionId, title, enabled, badgeText, badgeTextColor, badgeBackgroundColor)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      extensionId,
      title,
      enabled,
      badgeText,
      badgeTextColor,
      badgeBackgroundColor,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is WebExtensionData) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GeckoSuggestion (
  val id: String,
  val type: GeckoSuggestionType,
  val score: Long,
  val title: String? = null,
  val description: String? = null,
  val editSuggestion: String? = null,
  val icon: ByteArray? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeckoSuggestion {
      val id = pigeonVar_list[0] as String
      val type = pigeonVar_list[1] as GeckoSuggestionType
      val score = pigeonVar_list[2] as Long
      val title = pigeonVar_list[3] as String?
      val description = pigeonVar_list[4] as String?
      val editSuggestion = pigeonVar_list[5] as String?
      val icon = pigeonVar_list[6] as ByteArray?
      return GeckoSuggestion(id, type, score, title, description, editSuggestion, icon)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      id,
      type,
      score,
      title,
      description,
      editSuggestion,
      icon,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeckoSuggestion) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class TabContent (
  val tabId: String,
  val fullContentMarkdown: String? = null,
  val fullContentPlain: String? = null,
  val isProbablyReaderable: Boolean,
  val extractedContentMarkdown: String? = null,
  val extractedContentPlain: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TabContent {
      val tabId = pigeonVar_list[0] as String
      val fullContentMarkdown = pigeonVar_list[1] as String?
      val fullContentPlain = pigeonVar_list[2] as String?
      val isProbablyReaderable = pigeonVar_list[3] as Boolean
      val extractedContentMarkdown = pigeonVar_list[4] as String?
      val extractedContentPlain = pigeonVar_list[5] as String?
      return TabContent(tabId, fullContentMarkdown, fullContentPlain, isProbablyReaderable, extractedContentMarkdown, extractedContentPlain)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      tabId,
      fullContentMarkdown,
      fullContentPlain,
      isProbablyReaderable,
      extractedContentMarkdown,
      extractedContentPlain,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TabContent) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ContentBlocking (
  val queryParameterStripping: QueryParameterStripping,
  val queryParameterStrippingAllowList: String,
  val queryParameterStrippingStripList: String,
  val bounceTrackingProtectionMode: BounceTrackingProtectionMode
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ContentBlocking {
      val queryParameterStripping = pigeonVar_list[0] as QueryParameterStripping
      val queryParameterStrippingAllowList = pigeonVar_list[1] as String
      val queryParameterStrippingStripList = pigeonVar_list[2] as String
      val bounceTrackingProtectionMode = pigeonVar_list[3] as BounceTrackingProtectionMode
      return ContentBlocking(queryParameterStripping, queryParameterStrippingAllowList, queryParameterStrippingStripList, bounceTrackingProtectionMode)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      queryParameterStripping,
      queryParameterStrippingAllowList,
      queryParameterStrippingStripList,
      bounceTrackingProtectionMode,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ContentBlocking) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DohSettings (
  val dohSettingsMode: DohSettingsMode,
  val dohProviderUrl: String,
  val dohDefaultProviderUrl: String,
  val dohExceptionsList: List<String>
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): DohSettings {
      val dohSettingsMode = pigeonVar_list[0] as DohSettingsMode
      val dohProviderUrl = pigeonVar_list[1] as String
      val dohDefaultProviderUrl = pigeonVar_list[2] as String
      val dohExceptionsList = pigeonVar_list[3] as List<String>
      return DohSettings(dohSettingsMode, dohProviderUrl, dohDefaultProviderUrl, dohExceptionsList)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      dohSettingsMode,
      dohProviderUrl,
      dohDefaultProviderUrl,
      dohExceptionsList,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is DohSettings) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GeckoEngineSettings (
  val javascriptEnabled: Boolean? = null,
  val trackingProtectionPolicy: TrackingProtectionPolicy? = null,
  val httpsOnlyMode: HttpsOnlyMode? = null,
  val globalPrivacyControlEnabled: Boolean? = null,
  val preferredColorScheme: ColorScheme? = null,
  val cookieBannerHandlingMode: CookieBannerHandlingMode? = null,
  val cookieBannerHandlingModePrivateBrowsing: CookieBannerHandlingMode? = null,
  val cookieBannerHandlingGlobalRules: Boolean? = null,
  val cookieBannerHandlingGlobalRulesSubFrames: Boolean? = null,
  val webContentIsolationStrategy: WebContentIsolationStrategy? = null,
  val userAgent: String? = null,
  val contentBlocking: ContentBlocking? = null,
  val enterpriseRootsEnabled: Boolean? = null,
  val dohSettings: DohSettings? = null,
  val fingerprintingProtectionOverrides: String? = null,
  val locales: List<String>? = null,
  /** Master toggle for cookie blocking in Custom mode */
  val blockCookies: Boolean? = null,
  /** Cookie policy selection (only applies when blockCookies is true) */
  val customCookiePolicy: CustomCookiePolicy? = null,
  /** Block tracking scripts and content */
  val blockTrackingContent: Boolean? = null,
  /** Scope for tracking content blocking */
  val trackingContentScope: TrackingScope? = null,
  /** Block cryptomining scripts */
  val blockCryptominers: Boolean? = null,
  /** Block known fingerprinters (FINGERPRINTING tracking category) */
  val blockFingerprinters: Boolean? = null,
  /** Block redirect trackers via cookie purging */
  val blockRedirectTrackers: Boolean? = null,
  /**
   * Block suspected fingerprinters (separate from FINGERPRINTING category)
   * Controls GeckoView's fingerprintingProtection settings
   */
  val blockSuspectedFingerprinters: Boolean? = null,
  /** Scope for suspected fingerprinters blocking */
  val suspectedFingerprintersScope: TrackingScope? = null,
  /** Allow baseline tracking protection exceptions (prevents major site breakage) */
  val allowListBaseline: Boolean? = null,
  /** Allow convenience tracking protection exceptions (fixes minor issues) */
  val allowListConvenience: Boolean? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeckoEngineSettings {
      val javascriptEnabled = pigeonVar_list[0] as Boolean?
      val trackingProtectionPolicy = pigeonVar_list[1] as TrackingProtectionPolicy?
      val httpsOnlyMode = pigeonVar_list[2] as HttpsOnlyMode?
      val globalPrivacyControlEnabled = pigeonVar_list[3] as Boolean?
      val preferredColorScheme = pigeonVar_list[4] as ColorScheme?
      val cookieBannerHandlingMode = pigeonVar_list[5] as CookieBannerHandlingMode?
      val cookieBannerHandlingModePrivateBrowsing = pigeonVar_list[6] as CookieBannerHandlingMode?
      val cookieBannerHandlingGlobalRules = pigeonVar_list[7] as Boolean?
      val cookieBannerHandlingGlobalRulesSubFrames = pigeonVar_list[8] as Boolean?
      val webContentIsolationStrategy = pigeonVar_list[9] as WebContentIsolationStrategy?
      val userAgent = pigeonVar_list[10] as String?
      val contentBlocking = pigeonVar_list[11] as ContentBlocking?
      val enterpriseRootsEnabled = pigeonVar_list[12] as Boolean?
      val dohSettings = pigeonVar_list[13] as DohSettings?
      val fingerprintingProtectionOverrides = pigeonVar_list[14] as String?
      val locales = pigeonVar_list[15] as List<String>?
      val blockCookies = pigeonVar_list[16] as Boolean?
      val customCookiePolicy = pigeonVar_list[17] as CustomCookiePolicy?
      val blockTrackingContent = pigeonVar_list[18] as Boolean?
      val trackingContentScope = pigeonVar_list[19] as TrackingScope?
      val blockCryptominers = pigeonVar_list[20] as Boolean?
      val blockFingerprinters = pigeonVar_list[21] as Boolean?
      val blockRedirectTrackers = pigeonVar_list[22] as Boolean?
      val blockSuspectedFingerprinters = pigeonVar_list[23] as Boolean?
      val suspectedFingerprintersScope = pigeonVar_list[24] as TrackingScope?
      val allowListBaseline = pigeonVar_list[25] as Boolean?
      val allowListConvenience = pigeonVar_list[26] as Boolean?
      return GeckoEngineSettings(javascriptEnabled, trackingProtectionPolicy, httpsOnlyMode, globalPrivacyControlEnabled, preferredColorScheme, cookieBannerHandlingMode, cookieBannerHandlingModePrivateBrowsing, cookieBannerHandlingGlobalRules, cookieBannerHandlingGlobalRulesSubFrames, webContentIsolationStrategy, userAgent, contentBlocking, enterpriseRootsEnabled, dohSettings, fingerprintingProtectionOverrides, locales, blockCookies, customCookiePolicy, blockTrackingContent, trackingContentScope, blockCryptominers, blockFingerprinters, blockRedirectTrackers, blockSuspectedFingerprinters, suspectedFingerprintersScope, allowListBaseline, allowListConvenience)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      javascriptEnabled,
      trackingProtectionPolicy,
      httpsOnlyMode,
      globalPrivacyControlEnabled,
      preferredColorScheme,
      cookieBannerHandlingMode,
      cookieBannerHandlingModePrivateBrowsing,
      cookieBannerHandlingGlobalRules,
      cookieBannerHandlingGlobalRulesSubFrames,
      webContentIsolationStrategy,
      userAgent,
      contentBlocking,
      enterpriseRootsEnabled,
      dohSettings,
      fingerprintingProtectionOverrides,
      locales,
      blockCookies,
      customCookiePolicy,
      blockTrackingContent,
      trackingContentScope,
      blockCryptominers,
      blockFingerprinters,
      blockRedirectTrackers,
      blockSuspectedFingerprinters,
      suspectedFingerprintersScope,
      allowListBaseline,
      allowListConvenience,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeckoEngineSettings) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class AutocompleteResult (
  val input: String,
  val text: String,
  val url: String,
  val source: String,
  val totalItems: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AutocompleteResult {
      val input = pigeonVar_list[0] as String
      val text = pigeonVar_list[1] as String
      val url = pigeonVar_list[2] as String
      val source = pigeonVar_list[3] as String
      val totalItems = pigeonVar_list[4] as Long
      return AutocompleteResult(input, text, url, source, totalItems)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      input,
      text,
      url,
      source,
      totalItems,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is AutocompleteResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Represents all the different supported types of data that can be found from long clicking
 * an element.
 *
 * Generated class from Pigeon that represents data sent in messages.
 * This class should not be extended by any user class outside of the generated file.
 */
sealed class HitResult 
/**
 * Default type if we're unable to match the type to anything. It may or may not have a src.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class UnknownHitResult (
  val src: String
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): UnknownHitResult {
      val src = pigeonVar_list[0] as String
      return UnknownHitResult(src)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is UnknownHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * If the HTML element was of type 'HTMLImageElement'.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ImageHitResult (
  val src: String,
  val title: String? = null
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ImageHitResult {
      val src = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String?
      return ImageHitResult(src, title)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
      title,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ImageHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * If the HTML element was of type 'HTMLVideoElement'.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class VideoHitResult (
  val src: String,
  val title: String? = null
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): VideoHitResult {
      val src = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String?
      return VideoHitResult(src, title)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
      title,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is VideoHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * If the HTML element was of type 'HTMLAudioElement'.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class AudioHitResult (
  val src: String,
  val title: String? = null
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AudioHitResult {
      val src = pigeonVar_list[0] as String
      val title = pigeonVar_list[1] as String?
      return AudioHitResult(src, title)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
      title,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is AudioHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * If the HTML element was of type 'HTMLImageElement' and contained a URI.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class ImageSrcHitResult (
  val src: String,
  val uri: String
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ImageSrcHitResult {
      val src = pigeonVar_list[0] as String
      val uri = pigeonVar_list[1] as String
      return ImageSrcHitResult(src, uri)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
      uri,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ImageSrcHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * The type used if the URI is prepended with 'tel:'.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class PhoneHitResult (
  val src: String
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): PhoneHitResult {
      val src = pigeonVar_list[0] as String
      return PhoneHitResult(src)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is PhoneHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * The type used if the URI is prepended with 'mailto:'.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class EmailHitResult (
  val src: String
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): EmailHitResult {
      val src = pigeonVar_list[0] as String
      return EmailHitResult(src)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is EmailHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * The type used if the URI is prepended with 'geo:'.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class GeoHitResult (
  val src: String
) : HitResult()
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeoHitResult {
      val src = pigeonVar_list[0] as String
      return GeoHitResult(src)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      src,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeoHitResult) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class DownloadState (
  val url: String,
  val fileName: String? = null,
  val contentType: String? = null,
  val contentLength: Long? = null,
  val currentBytesCopied: Long? = null,
  val status: DownloadStatus? = null,
  val userAgent: String? = null,
  val destinationDirectory: String? = null,
  val directoryPath: String? = null,
  val referrerUrl: String? = null,
  val skipConfirmation: Boolean? = null,
  val openInApp: Boolean? = null,
  val id: String? = null,
  val sessionId: String? = null,
  val private: Boolean? = null,
  val createdTime: Long? = null,
  val notificationId: Long? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): DownloadState {
      val url = pigeonVar_list[0] as String
      val fileName = pigeonVar_list[1] as String?
      val contentType = pigeonVar_list[2] as String?
      val contentLength = pigeonVar_list[3] as Long?
      val currentBytesCopied = pigeonVar_list[4] as Long?
      val status = pigeonVar_list[5] as DownloadStatus?
      val userAgent = pigeonVar_list[6] as String?
      val destinationDirectory = pigeonVar_list[7] as String?
      val directoryPath = pigeonVar_list[8] as String?
      val referrerUrl = pigeonVar_list[9] as String?
      val skipConfirmation = pigeonVar_list[10] as Boolean?
      val openInApp = pigeonVar_list[11] as Boolean?
      val id = pigeonVar_list[12] as String?
      val sessionId = pigeonVar_list[13] as String?
      val private = pigeonVar_list[14] as Boolean?
      val createdTime = pigeonVar_list[15] as Long?
      val notificationId = pigeonVar_list[16] as Long?
      return DownloadState(url, fileName, contentType, contentLength, currentBytesCopied, status, userAgent, destinationDirectory, directoryPath, referrerUrl, skipConfirmation, openInApp, id, sessionId, private, createdTime, notificationId)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      fileName,
      contentType,
      contentLength,
      currentBytesCopied,
      status,
      userAgent,
      destinationDirectory,
      directoryPath,
      referrerUrl,
      skipConfirmation,
      openInApp,
      id,
      sessionId,
      private,
      createdTime,
      notificationId,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is DownloadState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ShareInternetResourceState (
  val url: String,
  val contentType: String? = null,
  val private: Boolean,
  val referrerUrl: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ShareInternetResourceState {
      val url = pigeonVar_list[0] as String
      val contentType = pigeonVar_list[1] as String?
      val private = pigeonVar_list[2] as Boolean
      val referrerUrl = pigeonVar_list[3] as String?
      return ShareInternetResourceState(url, contentType, private, referrerUrl)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      contentType,
      private,
      referrerUrl,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ShareInternetResourceState) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class AddonCollection (
  val serverURL: String,
  val collectionUser: String,
  val collectionName: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): AddonCollection {
      val serverURL = pigeonVar_list[0] as String
      val collectionUser = pigeonVar_list[1] as String
      val collectionName = pigeonVar_list[2] as String
      return AddonCollection(serverURL, collectionUser, collectionName)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      serverURL,
      collectionUser,
      collectionName,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is AddonCollection) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GeckoPref (
  val name: String,
  val value: Any? = null,
  val defaultValue: Any? = null,
  val userValue: Any? = null,
  val hasUserChangedValue: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeckoPref {
      val name = pigeonVar_list[0] as String
      val value = pigeonVar_list[1]
      val defaultValue = pigeonVar_list[2]
      val userValue = pigeonVar_list[3]
      val hasUserChangedValue = pigeonVar_list[4] as Boolean
      return GeckoPref(name, value, defaultValue, userValue, hasUserChangedValue)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      name,
      value,
      defaultValue,
      userValue,
      hasUserChangedValue,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeckoPref) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Progress information for ML model operations
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class MlProgressData (
  /** The type of ML model being loaded */
  val modelType: String,
  /** Percentage of completion (0-100) */
  val progress: Double,
  /** Type of operation (download, cache load, or inference) */
  val type: MlProgressType,
  /** Current status of the operation */
  val status: MlProgressStatus,
  /** Total bytes loaded so far */
  val totalLoaded: Long,
  /** Bytes loaded in current update */
  val currentLoaded: Long,
  /** Total size estimate */
  val total: Long,
  /** Units of measurement (e.g., "bytes") */
  val units: String,
  /** Whether the operation completed successfully */
  val ok: Boolean,
  /** Unique identifier for this operation */
  val id: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): MlProgressData {
      val modelType = pigeonVar_list[0] as String
      val progress = pigeonVar_list[1] as Double
      val type = pigeonVar_list[2] as MlProgressType
      val status = pigeonVar_list[3] as MlProgressStatus
      val totalLoaded = pigeonVar_list[4] as Long
      val currentLoaded = pigeonVar_list[5] as Long
      val total = pigeonVar_list[6] as Long
      val units = pigeonVar_list[7] as String
      val ok = pigeonVar_list[8] as Boolean
      val id = pigeonVar_list[9] as String?
      return MlProgressData(modelType, progress, type, status, totalLoaded, currentLoaded, total, units, ok, id)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      modelType,
      progress,
      type,
      status,
      totalLoaded,
      currentLoaded,
      total,
      units,
      ok,
      id,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is MlProgressData) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class ContainerSiteAssignment (
  val requestId: String,
  val tabId: String? = null,
  val originUrl: String? = null,
  val url: String,
  val blocked: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): ContainerSiteAssignment {
      val requestId = pigeonVar_list[0] as String
      val tabId = pigeonVar_list[1] as String?
      val originUrl = pigeonVar_list[2] as String?
      val url = pigeonVar_list[3] as String
      val blocked = pigeonVar_list[4] as Boolean
      return ContainerSiteAssignment(requestId, tabId, originUrl, url, blocked)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      requestId,
      tabId,
      originUrl,
      url,
      blocked,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is ContainerSiteAssignment) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GeckoHeader (
  val key: String,
  val value: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeckoHeader {
      val key = pigeonVar_list[0] as String
      val value = pigeonVar_list[1] as String
      return GeckoHeader(key, value)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      key,
      value,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeckoHeader) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GeckoFetchRequest (
  val url: String,
  val method: GeckoFetchMethod,
  val headers: List<GeckoHeader>,
  val connectTimeoutMillis: Long? = null,
  val readTimeoutMillis: Long? = null,
  val body: String? = null,
  val redirect: GeckoFetchRedircet,
  val cookiePolicy: GeckoFetchCookiePolicy,
  val useCaches: Boolean,
  val private: Boolean,
  val useOhttp: Boolean,
  val referrerUrl: String? = null,
  val conservative: Boolean
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeckoFetchRequest {
      val url = pigeonVar_list[0] as String
      val method = pigeonVar_list[1] as GeckoFetchMethod
      val headers = pigeonVar_list[2] as List<GeckoHeader>
      val connectTimeoutMillis = pigeonVar_list[3] as Long?
      val readTimeoutMillis = pigeonVar_list[4] as Long?
      val body = pigeonVar_list[5] as String?
      val redirect = pigeonVar_list[6] as GeckoFetchRedircet
      val cookiePolicy = pigeonVar_list[7] as GeckoFetchCookiePolicy
      val useCaches = pigeonVar_list[8] as Boolean
      val private = pigeonVar_list[9] as Boolean
      val useOhttp = pigeonVar_list[10] as Boolean
      val referrerUrl = pigeonVar_list[11] as String?
      val conservative = pigeonVar_list[12] as Boolean
      return GeckoFetchRequest(url, method, headers, connectTimeoutMillis, readTimeoutMillis, body, redirect, cookiePolicy, useCaches, private, useOhttp, referrerUrl, conservative)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      method,
      headers,
      connectTimeoutMillis,
      readTimeoutMillis,
      body,
      redirect,
      cookiePolicy,
      useCaches,
      private,
      useOhttp,
      referrerUrl,
      conservative,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeckoFetchRequest) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class GeckoFetchResponse (
  val url: String,
  val status: Long,
  val headers: List<GeckoHeader>,
  val body: ByteArray
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): GeckoFetchResponse {
      val url = pigeonVar_list[0] as String
      val status = pigeonVar_list[1] as Long
      val headers = pigeonVar_list[2] as List<GeckoHeader>
      val body = pigeonVar_list[3] as ByteArray
      return GeckoFetchResponse(url, status, headers, body)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
      status,
      headers,
      body,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is GeckoFetchResponse) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/** Generated class from Pigeon that represents data sent in messages. */
data class BookmarkNode (
  val type: BookmarkNodeType,
  val guid: String,
  val parentGuid: String? = null,
  val position: Long? = null,
  val title: String? = null,
  val url: String? = null,
  val dateAdded: Long,
  val lastModified: Long,
  val children: List<BookmarkNode>? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): BookmarkNode {
      val type = pigeonVar_list[0] as BookmarkNodeType
      val guid = pigeonVar_list[1] as String
      val parentGuid = pigeonVar_list[2] as String?
      val position = pigeonVar_list[3] as Long?
      val title = pigeonVar_list[4] as String?
      val url = pigeonVar_list[5] as String?
      val dateAdded = pigeonVar_list[6] as Long
      val lastModified = pigeonVar_list[7] as Long
      val children = pigeonVar_list[8] as List<BookmarkNode>?
      return BookmarkNode(type, guid, parentGuid, position, title, url, dateAdded, lastModified, children)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      type,
      guid,
      parentGuid,
      position,
      title,
      url,
      dateAdded,
      lastModified,
      children,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is BookmarkNode) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Class for making alterations to any bookmark node
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class BookmarkInfo (
  val parentGuid: String? = null,
  val position: Long? = null,
  val title: String? = null,
  val url: String? = null
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): BookmarkInfo {
      val parentGuid = pigeonVar_list[0] as String?
      val position = pigeonVar_list[1] as Long?
      val title = pigeonVar_list[2] as String?
      val url = pigeonVar_list[3] as String?
      return BookmarkInfo(parentGuid, position, title, url)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      parentGuid,
      position,
      title,
      url,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is BookmarkInfo) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Site permissions data structure
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class SitePermissions (
  val origin: String,
  val camera: SitePermissionStatus? = null,
  val microphone: SitePermissionStatus? = null,
  val location: SitePermissionStatus? = null,
  val notification: SitePermissionStatus? = null,
  val persistentStorage: SitePermissionStatus? = null,
  val crossOriginStorageAccess: SitePermissionStatus? = null,
  val mediaKeySystemAccess: SitePermissionStatus? = null,
  val localDeviceAccess: SitePermissionStatus? = null,
  val localNetworkAccess: SitePermissionStatus? = null,
  val autoplayAudible: AutoplayStatus? = null,
  val autoplayInaudible: AutoplayStatus? = null,
  val savedAt: Long
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): SitePermissions {
      val origin = pigeonVar_list[0] as String
      val camera = pigeonVar_list[1] as SitePermissionStatus?
      val microphone = pigeonVar_list[2] as SitePermissionStatus?
      val location = pigeonVar_list[3] as SitePermissionStatus?
      val notification = pigeonVar_list[4] as SitePermissionStatus?
      val persistentStorage = pigeonVar_list[5] as SitePermissionStatus?
      val crossOriginStorageAccess = pigeonVar_list[6] as SitePermissionStatus?
      val mediaKeySystemAccess = pigeonVar_list[7] as SitePermissionStatus?
      val localDeviceAccess = pigeonVar_list[8] as SitePermissionStatus?
      val localNetworkAccess = pigeonVar_list[9] as SitePermissionStatus?
      val autoplayAudible = pigeonVar_list[10] as AutoplayStatus?
      val autoplayInaudible = pigeonVar_list[11] as AutoplayStatus?
      val savedAt = pigeonVar_list[12] as Long
      return SitePermissions(origin, camera, microphone, location, notification, persistentStorage, crossOriginStorageAccess, mediaKeySystemAccess, localDeviceAccess, localNetworkAccess, autoplayAudible, autoplayInaudible, savedAt)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      origin,
      camera,
      microphone,
      location,
      notification,
      persistentStorage,
      crossOriginStorageAccess,
      mediaKeySystemAccess,
      localDeviceAccess,
      localNetworkAccess,
      autoplayAudible,
      autoplayInaudible,
      savedAt,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is SitePermissions) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}

/**
 * Tracking protection exception for a site
 *
 * This represents a site that has been added to the exceptions list,
 * meaning tracking protection is disabled for this specific site.
 *
 * Generated class from Pigeon that represents data sent in messages.
 */
data class TrackingProtectionException (
  val url: String
)
 {
  companion object {
    fun fromList(pigeonVar_list: List<Any?>): TrackingProtectionException {
      val url = pigeonVar_list[0] as String
      return TrackingProtectionException(url)
    }
  }
  fun toList(): List<Any?> {
    return listOf(
      url,
    )
  }
  override fun equals(other: Any?): Boolean {
    if (other !is TrackingProtectionException) {
      return false
    }
    if (this === other) {
      return true
    }
    return GeckoPigeonUtils.deepEquals(toList(), other.toList())  }

  override fun hashCode(): Int = toList().hashCode()
}
private open class GeckoPigeonCodec : StandardMessageCodec() {
  override fun readValueOfType(type: Byte, buffer: ByteBuffer): Any? {
    return when (type) {
      129.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          RestoreLocation.ofRaw(it.toInt())
        }
      }
      130.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IconType.ofRaw(it.toInt())
        }
      }
      131.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IconSize.ofRaw(it.toInt())
        }
      }
      132.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          IconSource.ofRaw(it.toInt())
        }
      }
      133.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CookieSameSiteStatus.ofRaw(it.toInt())
        }
      }
      134.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          VisitType.ofRaw(it.toInt())
        }
      }
      135.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          SelectionPattern.ofRaw(it.toInt())
        }
      }
      136.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          WebExtensionActionType.ofRaw(it.toInt())
        }
      }
      137.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          GeckoSuggestionType.ofRaw(it.toInt())
        }
      }
      138.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TrackingProtectionPolicy.ofRaw(it.toInt())
        }
      }
      139.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          HttpsOnlyMode.ofRaw(it.toInt())
        }
      }
      140.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          QueryParameterStripping.ofRaw(it.toInt())
        }
      }
      141.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BounceTrackingProtectionMode.ofRaw(it.toInt())
        }
      }
      142.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          ColorScheme.ofRaw(it.toInt())
        }
      }
      143.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CookieBannerHandlingMode.ofRaw(it.toInt())
        }
      }
      144.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AppLinksMode.ofRaw(it.toInt())
        }
      }
      145.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          WebContentIsolationStrategy.ofRaw(it.toInt())
        }
      }
      146.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          CustomCookiePolicy.ofRaw(it.toInt())
        }
      }
      147.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          TrackingScope.ofRaw(it.toInt())
        }
      }
      148.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          DohSettingsMode.ofRaw(it.toInt())
        }
      }
      149.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          DownloadStatus.ofRaw(it.toInt())
        }
      }
      150.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          LogLevel.ofRaw(it.toInt())
        }
      }
      151.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          MlProgressType.ofRaw(it.toInt())
        }
      }
      152.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          MlProgressStatus.ofRaw(it.toInt())
        }
      }
      153.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          ClearDataType.ofRaw(it.toInt())
        }
      }
      154.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          GeckoFetchMethod.ofRaw(it.toInt())
        }
      }
      155.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          GeckoFetchRedircet.ofRaw(it.toInt())
        }
      }
      156.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          GeckoFetchCookiePolicy.ofRaw(it.toInt())
        }
      }
      157.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          BookmarkNodeType.ofRaw(it.toInt())
        }
      }
      158.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          SitePermissionStatus.ofRaw(it.toInt())
        }
      }
      159.toByte() -> {
        return (readValue(buffer) as Long?)?.let {
          AutoplayStatus.ofRaw(it.toInt())
        }
      }
      160.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TranslationOptions.fromList(it)
        }
      }
      161.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ReaderState.fromList(it)
        }
      }
      162.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AddTabParams.fromList(it)
        }
      }
      163.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LastMediaAccessState.fromList(it)
        }
      }
      164.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryMetadataKey.fromList(it)
        }
      }
      165.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PackageCategoryValue.fromList(it)
        }
      }
      166.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ExternalPackage.fromList(it)
        }
      }
      167.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          LoadUrlFlagsValue.fromList(it)
        }
      }
      168.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SourceValue.fromList(it)
        }
      }
      169.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TabState.fromList(it)
        }
      }
      170.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RecoverableTab.fromList(it)
        }
      }
      171.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          RecoverableBrowserState.fromList(it)
        }
      }
      172.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          IconRequest.fromList(it)
        }
      }
      173.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ResourceSize.fromList(it)
        }
      }
      174.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Resource.fromList(it)
        }
      }
      175.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          IconResult.fromList(it)
        }
      }
      176.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CookiePartitionKey.fromList(it)
        }
      }
      177.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          Cookie.fromList(it)
        }
      }
      178.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VisitInfo.fromList(it)
        }
      }
      179.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryItem.fromList(it)
        }
      }
      180.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          HistoryState.fromList(it)
        }
      }
      181.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ReaderableState.fromList(it)
        }
      }
      182.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SecurityInfoState.fromList(it)
        }
      }
      183.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TabContentState.fromList(it)
        }
      }
      184.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          FindResultState.fromList(it)
        }
      }
      185.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          CustomSelectionAction.fromList(it)
        }
      }
      186.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          WebExtensionData.fromList(it)
        }
      }
      187.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeckoSuggestion.fromList(it)
        }
      }
      188.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TabContent.fromList(it)
        }
      }
      189.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ContentBlocking.fromList(it)
        }
      }
      190.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DohSettings.fromList(it)
        }
      }
      191.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeckoEngineSettings.fromList(it)
        }
      }
      192.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AutocompleteResult.fromList(it)
        }
      }
      193.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          UnknownHitResult.fromList(it)
        }
      }
      194.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageHitResult.fromList(it)
        }
      }
      195.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          VideoHitResult.fromList(it)
        }
      }
      196.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AudioHitResult.fromList(it)
        }
      }
      197.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ImageSrcHitResult.fromList(it)
        }
      }
      198.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          PhoneHitResult.fromList(it)
        }
      }
      199.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          EmailHitResult.fromList(it)
        }
      }
      200.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeoHitResult.fromList(it)
        }
      }
      201.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          DownloadState.fromList(it)
        }
      }
      202.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ShareInternetResourceState.fromList(it)
        }
      }
      203.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          AddonCollection.fromList(it)
        }
      }
      204.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeckoPref.fromList(it)
        }
      }
      205.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          MlProgressData.fromList(it)
        }
      }
      206.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          ContainerSiteAssignment.fromList(it)
        }
      }
      207.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeckoHeader.fromList(it)
        }
      }
      208.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeckoFetchRequest.fromList(it)
        }
      }
      209.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          GeckoFetchResponse.fromList(it)
        }
      }
      210.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          BookmarkNode.fromList(it)
        }
      }
      211.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          BookmarkInfo.fromList(it)
        }
      }
      212.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          SitePermissions.fromList(it)
        }
      }
      213.toByte() -> {
        return (readValue(buffer) as? List<Any?>)?.let {
          TrackingProtectionException.fromList(it)
        }
      }
      else -> super.readValueOfType(type, buffer)
    }
  }
  override fun writeValue(stream: ByteArrayOutputStream, value: Any?)   {
    when (value) {
      is RestoreLocation -> {
        stream.write(129)
        writeValue(stream, value.raw.toLong())
      }
      is IconType -> {
        stream.write(130)
        writeValue(stream, value.raw.toLong())
      }
      is IconSize -> {
        stream.write(131)
        writeValue(stream, value.raw.toLong())
      }
      is IconSource -> {
        stream.write(132)
        writeValue(stream, value.raw.toLong())
      }
      is CookieSameSiteStatus -> {
        stream.write(133)
        writeValue(stream, value.raw.toLong())
      }
      is VisitType -> {
        stream.write(134)
        writeValue(stream, value.raw.toLong())
      }
      is SelectionPattern -> {
        stream.write(135)
        writeValue(stream, value.raw.toLong())
      }
      is WebExtensionActionType -> {
        stream.write(136)
        writeValue(stream, value.raw.toLong())
      }
      is GeckoSuggestionType -> {
        stream.write(137)
        writeValue(stream, value.raw.toLong())
      }
      is TrackingProtectionPolicy -> {
        stream.write(138)
        writeValue(stream, value.raw.toLong())
      }
      is HttpsOnlyMode -> {
        stream.write(139)
        writeValue(stream, value.raw.toLong())
      }
      is QueryParameterStripping -> {
        stream.write(140)
        writeValue(stream, value.raw.toLong())
      }
      is BounceTrackingProtectionMode -> {
        stream.write(141)
        writeValue(stream, value.raw.toLong())
      }
      is ColorScheme -> {
        stream.write(142)
        writeValue(stream, value.raw.toLong())
      }
      is CookieBannerHandlingMode -> {
        stream.write(143)
        writeValue(stream, value.raw.toLong())
      }
      is AppLinksMode -> {
        stream.write(144)
        writeValue(stream, value.raw.toLong())
      }
      is WebContentIsolationStrategy -> {
        stream.write(145)
        writeValue(stream, value.raw.toLong())
      }
      is CustomCookiePolicy -> {
        stream.write(146)
        writeValue(stream, value.raw.toLong())
      }
      is TrackingScope -> {
        stream.write(147)
        writeValue(stream, value.raw.toLong())
      }
      is DohSettingsMode -> {
        stream.write(148)
        writeValue(stream, value.raw.toLong())
      }
      is DownloadStatus -> {
        stream.write(149)
        writeValue(stream, value.raw.toLong())
      }
      is LogLevel -> {
        stream.write(150)
        writeValue(stream, value.raw.toLong())
      }
      is MlProgressType -> {
        stream.write(151)
        writeValue(stream, value.raw.toLong())
      }
      is MlProgressStatus -> {
        stream.write(152)
        writeValue(stream, value.raw.toLong())
      }
      is ClearDataType -> {
        stream.write(153)
        writeValue(stream, value.raw.toLong())
      }
      is GeckoFetchMethod -> {
        stream.write(154)
        writeValue(stream, value.raw.toLong())
      }
      is GeckoFetchRedircet -> {
        stream.write(155)
        writeValue(stream, value.raw.toLong())
      }
      is GeckoFetchCookiePolicy -> {
        stream.write(156)
        writeValue(stream, value.raw.toLong())
      }
      is BookmarkNodeType -> {
        stream.write(157)
        writeValue(stream, value.raw.toLong())
      }
      is SitePermissionStatus -> {
        stream.write(158)
        writeValue(stream, value.raw.toLong())
      }
      is AutoplayStatus -> {
        stream.write(159)
        writeValue(stream, value.raw.toLong())
      }
      is TranslationOptions -> {
        stream.write(160)
        writeValue(stream, value.toList())
      }
      is ReaderState -> {
        stream.write(161)
        writeValue(stream, value.toList())
      }
      is AddTabParams -> {
        stream.write(162)
        writeValue(stream, value.toList())
      }
      is LastMediaAccessState -> {
        stream.write(163)
        writeValue(stream, value.toList())
      }
      is HistoryMetadataKey -> {
        stream.write(164)
        writeValue(stream, value.toList())
      }
      is PackageCategoryValue -> {
        stream.write(165)
        writeValue(stream, value.toList())
      }
      is ExternalPackage -> {
        stream.write(166)
        writeValue(stream, value.toList())
      }
      is LoadUrlFlagsValue -> {
        stream.write(167)
        writeValue(stream, value.toList())
      }
      is SourceValue -> {
        stream.write(168)
        writeValue(stream, value.toList())
      }
      is TabState -> {
        stream.write(169)
        writeValue(stream, value.toList())
      }
      is RecoverableTab -> {
        stream.write(170)
        writeValue(stream, value.toList())
      }
      is RecoverableBrowserState -> {
        stream.write(171)
        writeValue(stream, value.toList())
      }
      is IconRequest -> {
        stream.write(172)
        writeValue(stream, value.toList())
      }
      is ResourceSize -> {
        stream.write(173)
        writeValue(stream, value.toList())
      }
      is Resource -> {
        stream.write(174)
        writeValue(stream, value.toList())
      }
      is IconResult -> {
        stream.write(175)
        writeValue(stream, value.toList())
      }
      is CookiePartitionKey -> {
        stream.write(176)
        writeValue(stream, value.toList())
      }
      is Cookie -> {
        stream.write(177)
        writeValue(stream, value.toList())
      }
      is VisitInfo -> {
        stream.write(178)
        writeValue(stream, value.toList())
      }
      is HistoryItem -> {
        stream.write(179)
        writeValue(stream, value.toList())
      }
      is HistoryState -> {
        stream.write(180)
        writeValue(stream, value.toList())
      }
      is ReaderableState -> {
        stream.write(181)
        writeValue(stream, value.toList())
      }
      is SecurityInfoState -> {
        stream.write(182)
        writeValue(stream, value.toList())
      }
      is TabContentState -> {
        stream.write(183)
        writeValue(stream, value.toList())
      }
      is FindResultState -> {
        stream.write(184)
        writeValue(stream, value.toList())
      }
      is CustomSelectionAction -> {
        stream.write(185)
        writeValue(stream, value.toList())
      }
      is WebExtensionData -> {
        stream.write(186)
        writeValue(stream, value.toList())
      }
      is GeckoSuggestion -> {
        stream.write(187)
        writeValue(stream, value.toList())
      }
      is TabContent -> {
        stream.write(188)
        writeValue(stream, value.toList())
      }
      is ContentBlocking -> {
        stream.write(189)
        writeValue(stream, value.toList())
      }
      is DohSettings -> {
        stream.write(190)
        writeValue(stream, value.toList())
      }
      is GeckoEngineSettings -> {
        stream.write(191)
        writeValue(stream, value.toList())
      }
      is AutocompleteResult -> {
        stream.write(192)
        writeValue(stream, value.toList())
      }
      is UnknownHitResult -> {
        stream.write(193)
        writeValue(stream, value.toList())
      }
      is ImageHitResult -> {
        stream.write(194)
        writeValue(stream, value.toList())
      }
      is VideoHitResult -> {
        stream.write(195)
        writeValue(stream, value.toList())
      }
      is AudioHitResult -> {
        stream.write(196)
        writeValue(stream, value.toList())
      }
      is ImageSrcHitResult -> {
        stream.write(197)
        writeValue(stream, value.toList())
      }
      is PhoneHitResult -> {
        stream.write(198)
        writeValue(stream, value.toList())
      }
      is EmailHitResult -> {
        stream.write(199)
        writeValue(stream, value.toList())
      }
      is GeoHitResult -> {
        stream.write(200)
        writeValue(stream, value.toList())
      }
      is DownloadState -> {
        stream.write(201)
        writeValue(stream, value.toList())
      }
      is ShareInternetResourceState -> {
        stream.write(202)
        writeValue(stream, value.toList())
      }
      is AddonCollection -> {
        stream.write(203)
        writeValue(stream, value.toList())
      }
      is GeckoPref -> {
        stream.write(204)
        writeValue(stream, value.toList())
      }
      is MlProgressData -> {
        stream.write(205)
        writeValue(stream, value.toList())
      }
      is ContainerSiteAssignment -> {
        stream.write(206)
        writeValue(stream, value.toList())
      }
      is GeckoHeader -> {
        stream.write(207)
        writeValue(stream, value.toList())
      }
      is GeckoFetchRequest -> {
        stream.write(208)
        writeValue(stream, value.toList())
      }
      is GeckoFetchResponse -> {
        stream.write(209)
        writeValue(stream, value.toList())
      }
      is BookmarkNode -> {
        stream.write(210)
        writeValue(stream, value.toList())
      }
      is BookmarkInfo -> {
        stream.write(211)
        writeValue(stream, value.toList())
      }
      is SitePermissions -> {
        stream.write(212)
        writeValue(stream, value.toList())
      }
      is TrackingProtectionException -> {
        stream.write(213)
        writeValue(stream, value.toList())
      }
      else -> super.writeValue(stream, value)
    }
  }
}


/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoBrowserApi {
  fun getGeckoVersion(): String
  fun initialize(profileFolder: String, logLevel: LogLevel, contentBlocking: ContentBlocking, addonCollection: AddonCollection?)
  fun showNativeFragment(): Boolean
  fun onTrimMemory(level: Long)

  companion object {
    /** The codec used by GeckoBrowserApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoBrowserApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoBrowserApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.getGeckoVersion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getGeckoVersion())
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.initialize$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val profileFolderArg = args[0] as String
            val logLevelArg = args[1] as LogLevel
            val contentBlockingArg = args[2] as ContentBlocking
            val addonCollectionArg = args[3] as AddonCollection?
            val wrapped: List<Any?> = try {
              api.initialize(profileFolderArg, logLevelArg, contentBlockingArg, addonCollectionArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.showNativeFragment$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.showNativeFragment())
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserApi.onTrimMemory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val levelArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.onTrimMemory(levelArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoEngineSettingsApi {
  fun setDefaultSettings(settings: GeckoEngineSettings)
  fun updateRuntimeSettings(settings: GeckoEngineSettings)
  fun setPullToRefreshEnabled(enabled: Boolean)
  /**
   * Sets the app links mode preference (stored in SharedPreferences).
   * Controls how external app links are handled in the browser.
   */
  fun setAppLinksMode(mode: AppLinksMode)
  fun getAppLinksMode(): AppLinksMode

  companion object {
    /** The codec used by GeckoEngineSettingsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoEngineSettingsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoEngineSettingsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoEngineSettingsApi.setDefaultSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as GeckoEngineSettings
            val wrapped: List<Any?> = try {
              api.setDefaultSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoEngineSettingsApi.updateRuntimeSettings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val settingsArg = args[0] as GeckoEngineSettings
            val wrapped: List<Any?> = try {
              api.updateRuntimeSettings(settingsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoEngineSettingsApi.setPullToRefreshEnabled$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enabledArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.setPullToRefreshEnabled(enabledArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoEngineSettingsApi.setAppLinksMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val modeArg = args[0] as AppLinksMode
            val wrapped: List<Any?> = try {
              api.setAppLinksMode(modeArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoEngineSettingsApi.getAppLinksMode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              listOf(api.getAppLinksMode())
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoSessionApi {
  fun loadUrl(tabId: String?, url: String, flags: LoadUrlFlagsValue, additionalHeaders: Map<String, String>?)
  fun loadData(tabId: String?, data: String, mimeType: String, encoding: String)
  fun reload(tabId: String?, flags: LoadUrlFlagsValue)
  fun stopLoading(tabId: String?)
  fun goBack(tabId: String?, userInteraction: Boolean)
  fun goForward(tabId: String?, userInteraction: Boolean)
  fun goToHistoryIndex(index: Long, tabId: String?)
  fun requestDesktopSite(tabId: String?, enable: Boolean)
  fun exitFullscreen(tabId: String?)
  fun saveToPdf(tabId: String?)
  fun printContent(tabId: String?)
  fun translate(tabId: String?, fromLanguage: String, toLanguage: String, options: TranslationOptions?)
  fun translateRestore(tabId: String?)
  fun crashRecovery(tabIds: List<String>?)
  fun purgeHistory()
  fun updateLastAccess(tabId: String?, lastAccess: Long?)
  fun requestScreenshot(sendBack: Boolean, callback: (Result<ByteArray?>) -> Unit)

  companion object {
    /** The codec used by GeckoSessionApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoSessionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoSessionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val urlArg = args[1] as String
            val flagsArg = args[2] as LoadUrlFlagsValue
            val additionalHeadersArg = args[3] as Map<String, String>?
            val wrapped: List<Any?> = try {
              api.loadUrl(tabIdArg, urlArg, flagsArg, additionalHeadersArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.loadData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val dataArg = args[1] as String
            val mimeTypeArg = args[2] as String
            val encodingArg = args[3] as String
            val wrapped: List<Any?> = try {
              api.loadData(tabIdArg, dataArg, mimeTypeArg, encodingArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.reload$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val flagsArg = args[1] as LoadUrlFlagsValue
            val wrapped: List<Any?> = try {
              api.reload(tabIdArg, flagsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.stopLoading$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.stopLoading(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goBack$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val userInteractionArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.goBack(tabIdArg, userInteractionArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goForward$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val userInteractionArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.goForward(tabIdArg, userInteractionArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.goToHistoryIndex$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val indexArg = args[0] as Long
            val tabIdArg = args[1] as String?
            val wrapped: List<Any?> = try {
              api.goToHistoryIndex(indexArg, tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.requestDesktopSite$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val enableArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.requestDesktopSite(tabIdArg, enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.exitFullscreen$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.exitFullscreen(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.saveToPdf$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.saveToPdf(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.printContent$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.printContent(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translate$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val fromLanguageArg = args[1] as String
            val toLanguageArg = args[2] as String
            val optionsArg = args[3] as TranslationOptions?
            val wrapped: List<Any?> = try {
              api.translate(tabIdArg, fromLanguageArg, toLanguageArg, optionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.translateRestore$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.translateRestore(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.crashRecovery$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdsArg = args[0] as List<String>?
            val wrapped: List<Any?> = try {
              api.crashRecovery(tabIdsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.purgeHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.purgeHistory()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.updateLastAccess$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val lastAccessArg = args[1] as Long?
            val wrapped: List<Any?> = try {
              api.updateLastAccess(tabIdArg, lastAccessArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSessionApi.requestScreenshot$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val sendBackArg = args[0] as Boolean
            api.requestScreenshot(sendBackArg) { result: Result<ByteArray?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoTabsApi {
  fun syncEvents(onSelectedTabChange: Boolean, onTabListChange: Boolean, onTabContentStateChange: Boolean, onIconChange: Boolean, onSecurityInfoStateChange: Boolean, onReaderableStateChange: Boolean, onHistoryStateChange: Boolean, onFindResults: Boolean, onThumbnailChange: Boolean)
  fun selectTab(tabId: String)
  fun removeTab(tabId: String)
  fun addTab(url: String, selectTab: Boolean, startLoading: Boolean, parentId: String?, flags: LoadUrlFlagsValue, contextId: String?, source: SourceValue, private: Boolean, historyMetadata: HistoryMetadataKey?, additionalHeaders: Map<String, String>?): String
  fun addMultipleTabs(tabs: List<AddTabParams>, selectTabId: String?): List<String>
  fun removeAllTabs(recoverable: Boolean)
  fun removeTabs(ids: List<String>)
  fun removeNormalTabs()
  fun removePrivateTabs()
  fun undo()
  fun restoreTabsByList(tabs: List<RecoverableTab>, selectTabId: String?, restoreLocation: RestoreLocation)
  fun restoreTabsByBrowserState(state: RecoverableBrowserState, restoreLocation: RestoreLocation)
  /**
   * Selects an already existing tab with the matching [HistoryMetadataKey] or otherwise
   * creates a new tab with the given [url].
   */
  fun selectOrAddTabByHistory(url: String, historyMetadata: HistoryMetadataKey): String
  /** Selects an already existing tab displaying [url] or otherwise creates a new tab. */
  fun selectOrAddTabByUrl(url: String, private: Boolean, source: SourceValue, flags: LoadUrlFlagsValue, ignoreFragment: Boolean): String
  fun duplicateTab(selectTabId: String?, selectNewTab: Boolean, newContextId: String?): String
  fun moveTabs(tabIds: List<String>, targetTabId: String, placeAfter: Boolean)
  fun migratePrivateTabUseCase(tabId: String, alternativeUrl: String?): String

  companion object {
    /** The codec used by GeckoTabsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoTabsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoTabsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.syncEvents$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val onSelectedTabChangeArg = args[0] as Boolean
            val onTabListChangeArg = args[1] as Boolean
            val onTabContentStateChangeArg = args[2] as Boolean
            val onIconChangeArg = args[3] as Boolean
            val onSecurityInfoStateChangeArg = args[4] as Boolean
            val onReaderableStateChangeArg = args[5] as Boolean
            val onHistoryStateChangeArg = args[6] as Boolean
            val onFindResultsArg = args[7] as Boolean
            val onThumbnailChangeArg = args[8] as Boolean
            val wrapped: List<Any?> = try {
              api.syncEvents(onSelectedTabChangeArg, onTabListChangeArg, onTabContentStateChangeArg, onIconChangeArg, onSecurityInfoStateChangeArg, onReaderableStateChangeArg, onHistoryStateChangeArg, onFindResultsArg, onThumbnailChangeArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.selectTab(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.removeTab(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.addTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val selectTabArg = args[1] as Boolean
            val startLoadingArg = args[2] as Boolean
            val parentIdArg = args[3] as String?
            val flagsArg = args[4] as LoadUrlFlagsValue
            val contextIdArg = args[5] as String?
            val sourceArg = args[6] as SourceValue
            val privateArg = args[7] as Boolean
            val historyMetadataArg = args[8] as HistoryMetadataKey?
            val additionalHeadersArg = args[9] as Map<String, String>?
            val wrapped: List<Any?> = try {
              listOf(api.addTab(urlArg, selectTabArg, startLoadingArg, parentIdArg, flagsArg, contextIdArg, sourceArg, privateArg, historyMetadataArg, additionalHeadersArg))
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.addMultipleTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabsArg = args[0] as List<AddTabParams>
            val selectTabIdArg = args[1] as String?
            val wrapped: List<Any?> = try {
              listOf(api.addMultipleTabs(tabsArg, selectTabIdArg))
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeAllTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val recoverableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.removeAllTabs(recoverableArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idsArg = args[0] as List<String>
            val wrapped: List<Any?> = try {
              api.removeTabs(idsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removeNormalTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.removeNormalTabs()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.removePrivateTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.removePrivateTabs()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.undo$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.undo()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByList$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabsArg = args[0] as List<RecoverableTab>
            val selectTabIdArg = args[1] as String?
            val restoreLocationArg = args[2] as RestoreLocation
            val wrapped: List<Any?> = try {
              api.restoreTabsByList(tabsArg, selectTabIdArg, restoreLocationArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.restoreTabsByBrowserState$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val stateArg = args[0] as RecoverableBrowserState
            val restoreLocationArg = args[1] as RestoreLocation
            val wrapped: List<Any?> = try {
              api.restoreTabsByBrowserState(stateArg, restoreLocationArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val historyMetadataArg = args[1] as HistoryMetadataKey
            val wrapped: List<Any?> = try {
              listOf(api.selectOrAddTabByHistory(urlArg, historyMetadataArg))
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.selectOrAddTabByUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val privateArg = args[1] as Boolean
            val sourceArg = args[2] as SourceValue
            val flagsArg = args[3] as LoadUrlFlagsValue
            val ignoreFragmentArg = args[4] as Boolean
            val wrapped: List<Any?> = try {
              listOf(api.selectOrAddTabByUrl(urlArg, privateArg, sourceArg, flagsArg, ignoreFragmentArg))
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.duplicateTab$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val selectTabIdArg = args[0] as String?
            val selectNewTabArg = args[1] as Boolean
            val newContextIdArg = args[2] as String?
            val wrapped: List<Any?> = try {
              listOf(api.duplicateTab(selectTabIdArg, selectNewTabArg, newContextIdArg))
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.moveTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdsArg = args[0] as List<String>
            val targetTabIdArg = args[1] as String
            val placeAfterArg = args[2] as Boolean
            val wrapped: List<Any?> = try {
              api.moveTabs(tabIdsArg, targetTabIdArg, placeAfterArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabsApi.migratePrivateTabUseCase$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val alternativeUrlArg = args[1] as String?
            val wrapped: List<Any?> = try {
              listOf(api.migratePrivateTabUseCase(tabIdArg, alternativeUrlArg))
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoFindApi {
  fun findAll(tabId: String?, text: String)
  fun findNext(tabId: String?, forward: Boolean)
  fun clearMatches(tabId: String?)

  companion object {
    /** The codec used by GeckoFindApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoFindApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoFindApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFindApi.findAll$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val textArg = args[1] as String
            val wrapped: List<Any?> = try {
              api.findAll(tabIdArg, textArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFindApi.findNext$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val forwardArg = args[1] as Boolean
            val wrapped: List<Any?> = try {
              api.findNext(tabIdArg, forwardArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFindApi.clearMatches$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String?
            val wrapped: List<Any?> = try {
              api.clearMatches(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoIconsApi {
  fun loadIcon(request: IconRequest, callback: (Result<IconResult>) -> Unit)

  companion object {
    /** The codec used by GeckoIconsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoIconsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoIconsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoIconsApi.loadIcon$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val requestArg = args[0] as IconRequest
            api.loadIcon(requestArg) { result: Result<IconResult> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoPrefApi {
  fun getPrefList(callback: (Result<List<String>>) -> Unit)
  fun getPrefs(preferenceFilter: List<String>, callback: (Result<Map<String, GeckoPref>>) -> Unit)
  fun applyPrefs(prefs: Map<String, Any>, callback: (Result<Map<String, GeckoPref>>) -> Unit)
  fun resetPrefs(preferenceNames: List<String>, callback: (Result<Unit>) -> Unit)
  fun startObserveChanges()
  fun stopObserveChanges()
  fun registerPrefForObservation(name: String, callback: (Result<Unit>) -> Unit)
  fun unregisterPrefForObservation(name: String, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoPrefApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoPrefApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoPrefApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.getPrefList$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.getPrefList{ result: Result<List<String>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.getPrefs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val preferenceFilterArg = args[0] as List<String>
            api.getPrefs(preferenceFilterArg) { result: Result<Map<String, GeckoPref>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.applyPrefs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val prefsArg = args[0] as Map<String, Any>
            api.applyPrefs(prefsArg) { result: Result<Map<String, GeckoPref>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.resetPrefs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val preferenceNamesArg = args[0] as List<String>
            api.resetPrefs(preferenceNamesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.startObserveChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.startObserveChanges()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.stopObserveChanges$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.stopObserveChanges()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.registerPrefForObservation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as String
            api.registerPrefForObservation(nameArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPrefApi.unregisterPrefForObservation$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val nameArg = args[0] as String
            api.unregisterPrefForObservation(nameArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoMlApi {
  fun predictDocumentTopic(documents: List<String>, callback: (Result<String>) -> Unit)
  fun generateDocumentEmbeddings(documents: List<String>, callback: (Result<List<Any?>>) -> Unit)

  companion object {
    /** The codec used by GeckoMlApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoMlApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoMlApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoMlApi.predictDocumentTopic$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentsArg = args[0] as List<String>
            api.predictDocumentTopic(documentsArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoMlApi.generateDocumentEmbeddings$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val documentsArg = args[0] as List<String>
            api.generateDocumentEmbeddings(documentsArg) { result: Result<List<Any?>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoBrowserExtensionApi {
  fun getMarkdown(htmlList: List<String>, callback: (Result<List<Any>>) -> Unit)

  companion object {
    /** The codec used by GeckoBrowserExtensionApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoBrowserExtensionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoBrowserExtensionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBrowserExtensionApi.getMarkdown$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val htmlListArg = args[0] as List<String>
            api.getMarkdown(htmlListArg) { result: Result<List<Any>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoContainerProxyApi {
  fun setProxyPort(port: Long)
  fun addContainerProxy(contextId: String)
  fun removeContainerProxy(contextId: String)
  fun setSiteAssignments(assignments: Map<String, String>)
  fun healthcheck(callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by GeckoContainerProxyApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoContainerProxyApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoContainerProxyApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoContainerProxyApi.setProxyPort$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val portArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.setProxyPort(portArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoContainerProxyApi.addContainerProxy$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val contextIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.addContainerProxy(contextIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoContainerProxyApi.removeContainerProxy$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val contextIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.removeContainerProxy(contextIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoContainerProxyApi.setSiteAssignments$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val assignmentsArg = args[0] as Map<String, String>
            val wrapped: List<Any?> = try {
              api.setSiteAssignments(assignmentsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoContainerProxyApi.healthcheck$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.healthcheck{ result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoCookieApi {
  fun getCookie(firstPartyDomain: String?, name: String, partitionKey: CookiePartitionKey?, storeId: String?, url: String, callback: (Result<Cookie>) -> Unit)
  fun getAllCookies(domain: String?, firstPartyDomain: String?, name: String?, partitionKey: CookiePartitionKey?, storeId: String?, url: String, callback: (Result<List<Cookie>>) -> Unit)
  fun setCookie(domain: String?, expirationDate: Long?, firstPartyDomain: String?, httpOnly: Boolean?, name: String?, partitionKey: CookiePartitionKey?, path: String?, sameSite: CookieSameSiteStatus?, secure: Boolean?, storeId: String?, url: String, value: String?, callback: (Result<Unit>) -> Unit)
  fun removeCookie(firstPartyDomain: String?, name: String, partitionKey: CookiePartitionKey?, storeId: String?, url: String, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoCookieApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoCookieApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoCookieApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.getCookie$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val firstPartyDomainArg = args[0] as String?
            val nameArg = args[1] as String
            val partitionKeyArg = args[2] as CookiePartitionKey?
            val storeIdArg = args[3] as String?
            val urlArg = args[4] as String
            api.getCookie(firstPartyDomainArg, nameArg, partitionKeyArg, storeIdArg, urlArg) { result: Result<Cookie> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.getAllCookies$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val domainArg = args[0] as String?
            val firstPartyDomainArg = args[1] as String?
            val nameArg = args[2] as String?
            val partitionKeyArg = args[3] as CookiePartitionKey?
            val storeIdArg = args[4] as String?
            val urlArg = args[5] as String
            api.getAllCookies(domainArg, firstPartyDomainArg, nameArg, partitionKeyArg, storeIdArg, urlArg) { result: Result<List<Cookie>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.setCookie$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val domainArg = args[0] as String?
            val expirationDateArg = args[1] as Long?
            val firstPartyDomainArg = args[2] as String?
            val httpOnlyArg = args[3] as Boolean?
            val nameArg = args[4] as String?
            val partitionKeyArg = args[5] as CookiePartitionKey?
            val pathArg = args[6] as String?
            val sameSiteArg = args[7] as CookieSameSiteStatus?
            val secureArg = args[8] as Boolean?
            val storeIdArg = args[9] as String?
            val urlArg = args[10] as String
            val valueArg = args[11] as String?
            api.setCookie(domainArg, expirationDateArg, firstPartyDomainArg, httpOnlyArg, nameArg, partitionKeyArg, pathArg, sameSiteArg, secureArg, storeIdArg, urlArg, valueArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoCookieApi.removeCookie$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val firstPartyDomainArg = args[0] as String?
            val nameArg = args[1] as String
            val partitionKeyArg = args[2] as CookiePartitionKey?
            val storeIdArg = args[3] as String?
            val urlArg = args[4] as String
            api.removeCookie(firstPartyDomainArg, nameArg, partitionKeyArg, storeIdArg, urlArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoStateEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoStateEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onViewReadyStateChange(timestampArg: Long, stateArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onViewReadyStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onEngineReadyStateChange(timestampArg: Long, stateArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onEngineReadyStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onIconUpdate(timestampArg: Long, urlArg: String, bytesArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onIconUpdate$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, urlArg, bytesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onTabAdded(timestampArg: Long, tabIdArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabAdded$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, tabIdArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onTabListChange(timestampArg: Long, tabIdsArg: List<String>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabListChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, tabIdsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSelectedTabChange(timestampArg: Long, idArg: String?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSelectedTabChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onTabContentStateChange(timestampArg: Long, stateArg: TabContentState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onTabContentStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onHistoryStateChange(timestampArg: Long, idArg: String, stateArg: HistoryState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onHistoryStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onReaderableStateChange(timestampArg: Long, idArg: String, stateArg: ReaderableState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onReaderableStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onSecurityInfoStateChange(timestampArg: Long, idArg: String, stateArg: SecurityInfoState, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onSecurityInfoStateChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, stateArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onIconChange(timestampArg: Long, idArg: String, bytesArg: ByteArray?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onIconChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, bytesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onThumbnailChange(timestampArg: Long, idArg: String, bytesArg: ByteArray?, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onThumbnailChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, bytesArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onFindResults(timestampArg: Long, idArg: String, resultsArg: List<FindResultState>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onFindResults$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, resultsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onLongPress(timestampArg: Long, idArg: String, hitResultArg: HitResult, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onLongPress$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, idArg, hitResultArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onPreferenceChange(timestampArg: Long, valueArg: GeckoPref, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onPreferenceChange$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, valueArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onContainerSiteAssignment(timestampArg: Long, detailsArg: ContainerSiteAssignment, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onContainerSiteAssignment$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, detailsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onMlProgress(timestampArg: Long, progressArg: MlProgressData, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoStateEvents.onMlProgress$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, progressArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoLogging(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoLogging. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onLog(levelArg: LogLevel, messageArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoLogging.onLog$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(levelArg, messageArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface ReaderViewEvents {
  fun onToggleReaderView(enable: Boolean)
  fun onAppearanceButtonTap()

  companion object {
    /** The codec used by ReaderViewEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `ReaderViewEvents` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: ReaderViewEvents?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.ReaderViewEvents.onToggleReaderView$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val enableArg = args[0] as Boolean
            val wrapped: List<Any?> = try {
              api.onToggleReaderView(enableArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.ReaderViewEvents.onAppearanceButtonTap$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.onAppearanceButtonTap()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class ReaderViewController(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by ReaderViewController. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun appearanceButtonVisibility(timestampArg: Long, visibleArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.ReaderViewController.appearanceButtonVisibility$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, visibleArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoSelectionActionController {
  fun setActions(actions: List<CustomSelectionAction>)

  companion object {
    /** The codec used by GeckoSelectionActionController. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoSelectionActionController` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoSelectionActionController?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSelectionActionController.setActions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val actionsArg = args[0] as List<CustomSelectionAction>
            val wrapped: List<Any?> = try {
              api.setActions(actionsArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoSelectionActionEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoSelectionActionEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun performSelectionAction(idArg: String, selectedTextArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoSelectionActionEvents.performSelectionAction$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(idArg, selectedTextArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoAddonsApi {
  fun startAddonManagerActivity()
  fun invokeAddonAction(extensionId: String, actionType: WebExtensionActionType)
  fun installAddon(url: String, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoAddonsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoAddonsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoAddonsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoAddonsApi.startAddonManagerActivity$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            val wrapped: List<Any?> = try {
              api.startAddonManagerActivity()
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoAddonsApi.invokeAddonAction$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val extensionIdArg = args[0] as String
            val actionTypeArg = args[1] as WebExtensionActionType
            val wrapped: List<Any?> = try {
              api.invokeAddonAction(extensionIdArg, actionTypeArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoAddonsApi.installAddon$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            api.installAddon(urlArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoAddonEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoAddonEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onUpsertWebExtensionAction(timestampArg: Long, extensionIdArg: String, actionTypeArg: WebExtensionActionType, extensionDataArg: WebExtensionData, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoAddonEvents.onUpsertWebExtensionAction$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, extensionIdArg, actionTypeArg, extensionDataArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onRemoveWebExtensionAction(timestampArg: Long, extensionIdArg: String, actionTypeArg: WebExtensionActionType, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoAddonEvents.onRemoveWebExtensionAction$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, extensionIdArg, actionTypeArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
  fun onUpdateWebExtensionIcon(timestampArg: Long, extensionIdArg: String, actionTypeArg: WebExtensionActionType, iconArg: ByteArray, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoAddonEvents.onUpdateWebExtensionIcon$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, extensionIdArg, actionTypeArg, iconArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoSuggestionApi {
  fun getAutocompleteSuggestion(query: String, callback: (Result<AutocompleteResult?>) -> Unit)
  fun querySuggestions(text: String, providers: List<GeckoSuggestionType>)

  companion object {
    /** The codec used by GeckoSuggestionApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoSuggestionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoSuggestionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSuggestionApi.getAutocompleteSuggestion$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queryArg = args[0] as String
            api.getAutocompleteSuggestion(queryArg) { result: Result<AutocompleteResult?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSuggestionApi.querySuggestions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val textArg = args[0] as String
            val providersArg = args[1] as List<GeckoSuggestionType>
            val wrapped: List<Any?> = try {
              api.querySuggestions(textArg, providersArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoSuggestionEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoSuggestionEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onSuggestionResult(timestampArg: Long, suggestionTypeArg: GeckoSuggestionType, suggestionsArg: List<GeckoSuggestion>, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoSuggestionEvents.onSuggestionResult$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, suggestionTypeArg, suggestionsArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class GeckoTabContentEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoTabContentEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onContentUpdate(timestampArg: Long, contentArg: TabContent, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoTabContentEvents.onContentUpdate$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, contentArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoDeleteBrowsingDataController {
  fun deleteTabs(callback: (Result<Unit>) -> Unit)
  fun deleteBrowsingHistory(callback: (Result<Unit>) -> Unit)
  fun deleteCookiesAndSiteData(callback: (Result<Unit>) -> Unit)
  fun deleteCachedFiles(callback: (Result<Unit>) -> Unit)
  fun deleteSitePermissions(callback: (Result<Unit>) -> Unit)
  fun deleteDownloads(callback: (Result<Unit>) -> Unit)
  fun clearDataForSessionContext(contextId: String, callback: (Result<Unit>) -> Unit)
  /** Clear browsing data for a specific host/domain */
  fun clearDataForHost(host: String, dataTypes: List<ClearDataType>, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoDeleteBrowsingDataController. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoDeleteBrowsingDataController` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoDeleteBrowsingDataController?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.deleteTabs$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.deleteTabs{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.deleteBrowsingHistory$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.deleteBrowsingHistory{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.deleteCookiesAndSiteData$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.deleteCookiesAndSiteData{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.deleteCachedFiles$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.deleteCachedFiles{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.deleteSitePermissions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.deleteSitePermissions{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.deleteDownloads$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.deleteDownloads{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.clearDataForSessionContext$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val contextIdArg = args[0] as String
            api.clearDataForSessionContext(contextIdArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDeleteBrowsingDataController.clearDataForHost$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hostArg = args[0] as String
            val dataTypesArg = args[1] as List<ClearDataType>
            api.clearDataForHost(hostArg, dataTypesArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoHistoryApi {
  fun getDetailedVisits(startMillis: Long, endMillis: Long, excludeTypes: List<VisitType>, callback: (Result<List<VisitInfo>>) -> Unit)
  fun getVisitsPaginated(offset: Long, count: Long, excludeTypes: List<VisitType>, callback: (Result<List<VisitInfo>>) -> Unit)
  fun deleteVisit(url: String, timestamp: Long, callback: (Result<Unit>) -> Unit)
  fun deleteDownload(id: String, callback: (Result<Unit>) -> Unit)
  fun deleteVisitsBetween(startMillis: Long, endMillis: Long, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoHistoryApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoHistoryApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoHistoryApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoHistoryApi.getDetailedVisits$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val startMillisArg = args[0] as Long
            val endMillisArg = args[1] as Long
            val excludeTypesArg = args[2] as List<VisitType>
            api.getDetailedVisits(startMillisArg, endMillisArg, excludeTypesArg) { result: Result<List<VisitInfo>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoHistoryApi.getVisitsPaginated$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val offsetArg = args[0] as Long
            val countArg = args[1] as Long
            val excludeTypesArg = args[2] as List<VisitType>
            api.getVisitsPaginated(offsetArg, countArg, excludeTypesArg) { result: Result<List<VisitInfo>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoHistoryApi.deleteVisit$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            val timestampArg = args[1] as Long
            api.deleteVisit(urlArg, timestampArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoHistoryApi.deleteDownload$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val idArg = args[0] as String
            api.deleteDownload(idArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoHistoryApi.deleteVisitsBetween$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val startMillisArg = args[0] as Long
            val endMillisArg = args[1] as Long
            api.deleteVisitsBetween(startMillisArg, endMillisArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoDownloadsApi {
  fun requestDownload(tabId: String, state: DownloadState)
  fun copyInternetResource(tabId: String, state: ShareInternetResourceState)
  fun shareInternetResource(tabId: String, state: ShareInternetResourceState)

  companion object {
    /** The codec used by GeckoDownloadsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoDownloadsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoDownloadsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDownloadsApi.requestDownload$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val stateArg = args[1] as DownloadState
            val wrapped: List<Any?> = try {
              api.requestDownload(tabIdArg, stateArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDownloadsApi.copyInternetResource$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val stateArg = args[1] as ShareInternetResourceState
            val wrapped: List<Any?> = try {
              api.copyInternetResource(tabIdArg, stateArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoDownloadsApi.shareInternetResource$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val stateArg = args[1] as ShareInternetResourceState
            val wrapped: List<Any?> = try {
              api.shareInternetResource(tabIdArg, stateArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/** Generated class from Pigeon that represents Flutter messages that can be called from Kotlin. */
class BrowserExtensionEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by BrowserExtensionEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  fun onFeedRequested(timestampArg: Long, urlArg: String, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.BrowserExtensionEvents.onFeedRequested$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, urlArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoFetchApi {
  fun fetch(request: GeckoFetchRequest, callback: (Result<GeckoFetchResponse>) -> Unit)

  companion object {
    /** The codec used by GeckoFetchApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoFetchApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoFetchApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoFetchApi.fetch$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val requestArg = args[0] as GeckoFetchRequest
            api.fetch(requestArg) { result: Result<GeckoFetchResponse> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Controls GeckoView's viewport behavior for dynamic toolbar and keyboard handling.
 *
 * This API allows Flutter to control how GeckoView adjusts its internal viewport
 * without resizing the platform view itself, avoiding visual flickering.
 *
 * The dynamic toolbar system works by:
 * 1. Setting the maximum toolbar height via [setDynamicToolbarMaxHeight]
 * 2. Updating the vertical clipping as toolbar animates via [setVerticalClipping]
 * 3. GeckoView internally adjusts viewport and notifies the website
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GeckoViewportApi {
  /**
   * Sets the maximum height that dynamic toolbars (top + bottom) can occupy.
   *
   * GeckoView will adjust its internal viewport calculations to account for
   * this space. The website will receive proper viewport dimensions through
   * standard web APIs (CSS viewport units, window.innerHeight).
   *
   * Call this once when toolbar dimensions are known, and again if they change.
   *
   * [heightPx] Combined height of top and bottom toolbars in pixels.
   */
  fun setDynamicToolbarMaxHeight(heightPx: Long)
  /**
   * Sets the vertical clipping offset for the GeckoView content.
   *
   * Use this as the toolbar animates to clip content at the bottom.
   * Negative values clip from the bottom (for bottom toolbar sliding up).
   * Positive values clip from the top (for top toolbar sliding down).
   *
   * Call this during toolbar animation frames to smoothly adjust the visible area.
   *
   * [clippingPx] The clipping offset in pixels. Negative = bottom clip.
   */
  fun setVerticalClipping(clippingPx: Long)

  companion object {
    /** The codec used by GeckoViewportApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoViewportApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoViewportApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoViewportApi.setDynamicToolbarMaxHeight$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val heightPxArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.setDynamicToolbarMaxHeight(heightPxArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoViewportApi.setVerticalClipping$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val clippingPxArg = args[0] as Long
            val wrapped: List<Any?> = try {
              api.setVerticalClipping(clippingPxArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Events from native side about viewport and input-related changes.
 *
 * These events allow Flutter to react to native viewport changes,
 * particularly keyboard visibility which is detected natively.
 *
 * Generated class from Pigeon that represents Flutter messages that can be called from Kotlin.
 */
class GeckoViewportEvents(private val binaryMessenger: BinaryMessenger, private val messageChannelSuffix: String = "") {
  companion object {
    /** The codec used by GeckoViewportEvents. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
  }
  /**
   * Called when keyboard visibility changes.
   *
   * This is detected natively using WindowInsets API and provides
   * accurate keyboard height information.
   *
   * [timestamp] Event timestamp for ordering.
   * [heightPx] Keyboard height in pixels (0 when hidden).
   * [isVisible] Whether the keyboard is currently visible.
   * [isAnimating] Whether the keyboard is currently animating.
   */
  fun onKeyboardVisibilityChanged(timestampArg: Long, heightPxArg: Long, isVisibleArg: Boolean, isAnimatingArg: Boolean, callback: (Result<Unit>) -> Unit)
{
    val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
    val channelName = "dev.flutter.pigeon.flutter_mozilla_components.GeckoViewportEvents.onKeyboardVisibilityChanged$separatedMessageChannelSuffix"
    val channel = BasicMessageChannel<Any?>(binaryMessenger, channelName, codec)
    channel.send(listOf(timestampArg, heightPxArg, isVisibleArg, isAnimatingArg)) {
      if (it is List<*>) {
        if (it.size > 1) {
          callback(Result.failure(FlutterError(it[0] as String, it[1] as String, it[2] as String?)))
        } else {
          callback(Result.success(Unit))
        }
      } else {
        callback(Result.failure(GeckoPigeonUtils.createConnectionError(channelName)))
      } 
    }
  }
}
/** Generated interface from Pigeon that represents a handler of messages from Flutter. */
interface GeckoBookmarksApi {
  /**
   * Produces a bookmarks tree for the given guid string.
   *
   * @param guid The bookmark guid to obtain.
   * @param recursive Whether to recurse and obtain all levels of children.
   * @return The populated root starting from the guid.
   */
  fun getTree(guid: String, recursive: Boolean, callback: (Result<BookmarkNode?>) -> Unit)
  /**
   * Obtains the details of a bookmark without children, if one exists with that guid. Otherwise, null.
   *
   * @param guid The bookmark guid to obtain.
   * @return The bookmark node or null if it does not exist.
   */
  fun getBookmark(guid: String, callback: (Result<BookmarkNode?>) -> Unit)
  /**
   * Produces a list of all bookmarks with the given URL.
   *
   * @param url The URL string.
   * @return The list of bookmarks that match the URL
   */
  fun getBookmarksWithUrl(url: String, callback: (Result<List<BookmarkNode>>) -> Unit)
  /**
   * Produces a list of the most recently added bookmarks.
   *
   * @param limit The maximum number of entries to return.
   * @param maxAge Optional parameter used to filter out entries older than this number of milliseconds.
   * @param currentTime Optional parameter for current time. Defaults toSystem.currentTimeMillis()
   * @return The list of bookmarks that have been recently added up to the limit number of items.
   */
  fun getRecentBookmarks(limit: Long, maxAge: Long?, currentTime: Long, callback: (Result<List<BookmarkNode>>) -> Unit)
  /**
   * Searches bookmarks with a query string.
   *
   * @param query The query string to search.
   * @param limit The maximum number of entries to return.
   * @return The list of matching bookmark nodes up to the limit number of items.
   */
  fun searchBookmarks(query: String, limit: Long, callback: (Result<List<BookmarkNode>>) -> Unit)
  /**
   * Adds a new bookmark item to a given node.
   *
   * Sync behavior: will add new bookmark item to remote devices.
   *
   * @param parentGuid The parent guid of the new node.
   * @param url The URL of the bookmark item to add.
   * @param title The title of the bookmark item to add.
   * @param position The optional position to add the new node or null to append.
   * @return The guid of the newly inserted bookmark item.
   */
  fun addItem(parentGuid: String, url: String, title: String, position: Long?, callback: (Result<String>) -> Unit)
  /**
   * Adds a new bookmark folder to a given node.
   *
   * Sync behavior: will add new separator to remote devices.
   *
   * @param parentGuid The parent guid of the new node.
   * @param title The title of the bookmark folder to add.
   * @param position The optional position to add the new node or null to append.
   * @return The guid of the newly inserted bookmark item.
   */
  fun addFolder(parentGuid: String, title: String, position: Long?, callback: (Result<String>) -> Unit)
  /**
   * Edits the properties of an existing bookmark item and/or moves an existing one underneath a new parent guid.
   *
   * Sync behavior: will alter bookmark item on remote devices.
   *
   * @param guid The guid of the item to update.
   * @param info The info to change in the bookmark.
   */
  fun updateNode(guid: String, info: BookmarkInfo, callback: (Result<Unit>) -> Unit)
  /**
   * Deletes a bookmark node and all of its children, if any.
   *
   * Sync behavior: will remove bookmark from remote devices.
   *
   * @return Whether the bookmark existed or not.
   */
  fun deleteNode(guid: String, callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by GeckoBookmarksApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoBookmarksApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoBookmarksApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.getTree$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val guidArg = args[0] as String
            val recursiveArg = args[1] as Boolean
            api.getTree(guidArg, recursiveArg) { result: Result<BookmarkNode?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.getBookmark$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val guidArg = args[0] as String
            api.getBookmark(guidArg) { result: Result<BookmarkNode?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.getBookmarksWithUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            api.getBookmarksWithUrl(urlArg) { result: Result<List<BookmarkNode>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.getRecentBookmarks$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val limitArg = args[0] as Long
            val maxAgeArg = args[1] as Long?
            val currentTimeArg = args[2] as Long
            api.getRecentBookmarks(limitArg, maxAgeArg, currentTimeArg) { result: Result<List<BookmarkNode>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.searchBookmarks$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val queryArg = args[0] as String
            val limitArg = args[1] as Long
            api.searchBookmarks(queryArg, limitArg) { result: Result<List<BookmarkNode>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.addItem$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val parentGuidArg = args[0] as String
            val urlArg = args[1] as String
            val titleArg = args[2] as String
            val positionArg = args[3] as Long?
            api.addItem(parentGuidArg, urlArg, titleArg, positionArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.addFolder$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val parentGuidArg = args[0] as String
            val titleArg = args[1] as String
            val positionArg = args[2] as Long?
            api.addFolder(parentGuidArg, titleArg, positionArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.updateNode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val guidArg = args[0] as String
            val infoArg = args[1] as BookmarkInfo
            api.updateNode(guidArg, infoArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoBookmarksApi.deleteNode$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val guidArg = args[0] as String
            api.deleteNode(guidArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for managing site permissions stored in GeckoView
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GeckoSitePermissionsApi {
  /** Get permissions for origin (single source of truth from GeckoView) */
  fun getSitePermissions(origin: String, private: Boolean, callback: (Result<SitePermissions?>) -> Unit)
  /** Save/update permissions (persisted by GeckoView) */
  fun setSitePermissions(permissions: SitePermissions, private: Boolean, callback: (Result<Unit>) -> Unit)
  /** Delete permissions for origin (removed from GeckoView storage) */
  fun deleteSitePermissions(origin: String, private: Boolean, callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoSitePermissionsApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoSitePermissionsApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoSitePermissionsApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSitePermissionsApi.getSitePermissions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val originArg = args[0] as String
            val privateArg = args[1] as Boolean
            api.getSitePermissions(originArg, privateArg) { result: Result<SitePermissions?> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSitePermissionsApi.setSitePermissions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val permissionsArg = args[0] as SitePermissions
            val privateArg = args[1] as Boolean
            api.setSitePermissions(permissionsArg, privateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoSitePermissionsApi.deleteSitePermissions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val originArg = args[0] as String
            val privateArg = args[1] as Boolean
            api.deleteSitePermissions(originArg, privateArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * Native wrapper for Mozilla's Public Suffix List
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GeckoPublicSuffixListApi {
  /**
   * Get base domain (eTLD+1) from host using Mozilla's Public Suffix List
   * Returns the host unchanged if PSL lookup fails
   */
  fun getPublicSuffixPlusOne(host: String, callback: (Result<String>) -> Unit)

  companion object {
    /** The codec used by GeckoPublicSuffixListApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoPublicSuffixListApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoPublicSuffixListApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoPublicSuffixListApi.getPublicSuffixPlusOne$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val hostArg = args[0] as String
            api.getPublicSuffixPlusOne(hostArg) { result: Result<String> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for managing per-site tracking protection exceptions
 *
 * This API wraps Mozilla Android Components' TrackingProtectionUseCases
 * to allow Flutter code to add/remove/check tracking protection exceptions
 * on a per-site basis.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GeckoTrackingProtectionApi {
  /**
   * Check if a tab has a tracking protection exception
   *
   * Uses callback pattern to match Mozilla Android Components API.
   * Returns true if the site is in the exceptions list (ETP disabled).
   */
  fun containsException(tabId: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Add tracking protection exception for a tab (disable ETP for this site)
   *
   * This adds the current tab's URL to the exceptions list.
   * ETP will be disabled for this site until the exception is removed.
   */
  fun addException(tabId: String)
  /**
   * Remove tracking protection exception for a tab (enable ETP for this site)
   *
   * This removes the current tab's URL from the exceptions list.
   * ETP will be re-enabled for this site.
   */
  fun removeException(tabId: String)
  /**
   * Remove a specific exception by URL
   *
   * Alternative to removeException(tabId) for cases where you
   * have a URL rather than a tabId.
   */
  fun removeExceptionByUrl(url: String, callback: (Result<Unit>) -> Unit)
  /**
   * Fetch all tracking protection exceptions
   *
   * Returns list of all sites that have exceptions (ETP disabled).
   */
  fun fetchExceptions(callback: (Result<List<TrackingProtectionException>>) -> Unit)
  /**
   * Remove all tracking protection exceptions
   *
   * This re-enables ETP for all exception sites.
   */
  fun removeAllExceptions(callback: (Result<Unit>) -> Unit)

  companion object {
    /** The codec used by GeckoTrackingProtectionApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoTrackingProtectionApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoTrackingProtectionApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTrackingProtectionApi.containsException$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            api.containsException(tabIdArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTrackingProtectionApi.addException$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.addException(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTrackingProtectionApi.removeException$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val tabIdArg = args[0] as String
            val wrapped: List<Any?> = try {
              api.removeException(tabIdArg)
              listOf(null)
            } catch (exception: Throwable) {
              GeckoPigeonUtils.wrapError(exception)
            }
            reply.reply(wrapped)
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTrackingProtectionApi.removeExceptionByUrl$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            api.removeExceptionByUrl(urlArg) { result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTrackingProtectionApi.fetchExceptions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.fetchExceptions{ result: Result<List<TrackingProtectionException>> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoTrackingProtectionApi.removeAllExceptions$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { _, reply ->
            api.removeAllExceptions{ result: Result<Unit> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                reply.reply(GeckoPigeonUtils.wrapResult(null))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
/**
 * API for detecting and launching external applications that can handle URLs.
 *
 * This API wraps Mozilla Android Components' AppLinksUseCases to allow Flutter
 * code to check if native apps can handle URLs and launch them directly.
 *
 * Generated interface from Pigeon that represents a handler of messages from Flutter.
 */
interface GeckoAppLinksApi {
  /**
   * Checks if an external application is available to handle the given URL.
   *
   * This method uses mozilla-components AppLinksUseCases to determine if
   * a native app can handle the URL (e.g., YouTube app for youtube.com links).
   *
   * Returns true if an external app is available, false otherwise.
   */
  fun hasExternalApp(url: String, callback: (Result<Boolean>) -> Unit)
  /**
   * Opens the URL in an external application if available.
   *
   * This method will:
   * 1. Check if an external app can handle the URL
   * 2. If available, launch the app directly with Intent.FLAG_ACTIVITY_NEW_TASK
   * 3. Return true if successfully launched, false otherwise
   *
   * Returns true if URL was opened in external app, false if no app available.
   */
  fun openAppLink(url: String, callback: (Result<Boolean>) -> Unit)

  companion object {
    /** The codec used by GeckoAppLinksApi. */
    val codec: MessageCodec<Any?> by lazy {
      GeckoPigeonCodec()
    }
    /** Sets up an instance of `GeckoAppLinksApi` to handle messages through the `binaryMessenger`. */
    @JvmOverloads
    fun setUp(binaryMessenger: BinaryMessenger, api: GeckoAppLinksApi?, messageChannelSuffix: String = "") {
      val separatedMessageChannelSuffix = if (messageChannelSuffix.isNotEmpty()) ".$messageChannelSuffix" else ""
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoAppLinksApi.hasExternalApp$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            api.hasExternalApp(urlArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
      run {
        val channel = BasicMessageChannel<Any?>(binaryMessenger, "dev.flutter.pigeon.flutter_mozilla_components.GeckoAppLinksApi.openAppLink$separatedMessageChannelSuffix", codec)
        if (api != null) {
          channel.setMessageHandler { message, reply ->
            val args = message as List<Any?>
            val urlArg = args[0] as String
            api.openAppLink(urlArg) { result: Result<Boolean> ->
              val error = result.exceptionOrNull()
              if (error != null) {
                reply.reply(GeckoPigeonUtils.wrapError(error))
              } else {
                val data = result.getOrNull()
                reply.reply(GeckoPigeonUtils.wrapResult(data))
              }
            }
          }
        } else {
          channel.setMessageHandler(null)
        }
      }
    }
  }
}
